{"version":3,"file":"current.min.js","sources":["../../js/std-js/trust.js","../../js/std-js/utility.js","../../js/std-js/promises.js","../../js/std-js/events.js","../../js/std-js/abort.js","../../js/std-js/Lock.js","../../js/std-js/LockManager.js","../../js/std-js/types.js","../../js/std-js/attrs.js","../../js/std-js/dom.js","../../js/std-js/HTTPException.js","../../js/std-js/http.js","../../js/std-js/namespaces.js","../../js/std-js/svg.js","helper.js","../../import.meta.js","../../js/std-js/custom-elements.js","../../js/std-js/intersect.js","../custom-element.js","current.js"],"sourcesContent":["/**\n * @copyright 2023 Chris Zuber <admin@kernvalley.us>\n */\nimport { callOnce } from './utility.js';\n\nexport function setProp(el, prop, val, {\n\tpolicy,\n} = {}) {\n\tswitch(getPropertyType(el.tagName, prop)) {\n\t\tcase 'TrustedScript':\n\t\t\tel[prop] = createScript(val, { policy });\n\t\t\tbreak;\n\n\t\tcase 'TrustedScriptURL':\n\t\t\tel[prop] = createScriptURL(val, { policy });\n\t\t\tbreak;\n\n\t\tcase 'TrustedHTML':\n\t\t\tel[prop] = createHTML(val, { policy });\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tel[prop] = val;\n\t}\n}\n\nexport function setAttr(el, attr, val, {\n\telementNs,\n\tpolicy,\n} = {}) {\n\tswitch(getAttributeType(el.tagName, attr, elementNs)) {\n\t\tcase 'TrustedScriptURL':\n\t\t\tif (typeof elementNs === 'string') {\n\t\t\t\tel.setAttributeNs(elementNs, attr, createScriptURL(val, { policy }));\n\t\t\t} else {\n\t\t\t\tel.setAttribute(attr, createScriptURL(val, { policy }));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'TrustedScript':\n\t\t\tif (typeof elementNs === 'string') {\n\t\t\t\tel.setAttributeNS(elementNs, attr, createScript(val, { policy }));\n\t\t\t} else {\n\t\t\t\tel.setAttribute(attr, createScript(val, { policy }));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase 'TrustedHTML':\n\t\t\tif (typeof elementNs === 'string') {\n\t\t\t\tel.setAttributeNS(elementNs, attr, createHTML(val, { policy }));\n\t\t\t} else {\n\t\t\t\tel.setAttribute(attr, createHTML(val, { policy }));\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tif (typeof elementNs === 'string') {\n\t\t\t\tel.setAttributeNS(elementNs, attr, val);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(attr, val);\n\t\t\t}\n\t}\n}\n\nexport function supported() {\n\treturn 'trustedTypes' in globalThis\n\t\t&& trustedTypes instanceof EventTarget\n\t\t&& trustedTypes.createPolicy instanceof Function;\n}\n\nexport function isTrustPolicy(policy) {\n\tif ('TrustedTypePolicy' in globalThis && policy instanceof TrustedTypePolicy) {\n\t\treturn true;\n\t} else {\n\t\treturn policy != null && policy.createHTML instanceof Function;\n\t}\n}\n\nexport function hasDefaultPolicy() {\n\treturn supported() && isTrustPolicy(trustedTypes.defaultPolicy);\n}\n\nexport function getAttributeType(tagName, attribute, elementNs) {\n\tif (supported()) {\n\t\treturn trustedTypes.getAttributeType(tagName.toLowerCase(), attribute, elementNs);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport function getPropertyType(tagName, property) {\n\tif (supported()) {\n\t\treturn trustedTypes.getPropertyType(tagName.toLowerCase(), property);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport function isHTML(input) {\n\tif (supported()) {\n\t\treturn trustedTypes.isHTML(input);\n\t} else {\n\t\treturn typeof input === 'string';\n\t}\n}\n\nexport function isScript(input) {\n\tif (supported()) {\n\t\treturn trustedTypes.isScript(input);\n\t} else {\n\t\treturn typeof input === 'string';\n\t}\n}\n\nexport function isScriptURL(input) {\n\tif (supported()) {\n\t\treturn trustedTypes.isScriptURL(input);\n\t} else {\n\t\treturn typeof input === 'string' || input instanceof URL;\n\t}\n}\n\nexport function isTrustedType(input) {\n\tif (supported()) {\n\t\treturn trustedTypes.isHTML(input) || trustedTypes.isScript(input) || trustedTypes.isScriptURL(input);\n\t} else {\n\t\treturn true;\n\t}\n}\n\nexport function createHTML(input, { policy = getDefaultPolicy() } = {}) {\n\tif (isTrustPolicy(policy) && ! isHTML(input)) {\n\t\treturn policy.createHTML(input);\n\t} else {\n\t\treturn input;\n\t}\n}\n\nexport function createScript(input, { policy = getDefaultPolicy() } = {}) {\n\tif (isTrustPolicy(policy) && ! isScript(input)) {\n\t\treturn policy.createScript(input);\n\t} else {\n\t\treturn input;\n\t}\n}\n\nexport function createScriptURL(input, { policy = getDefaultPolicy() } = {}) {\n\tif (isTrustPolicy(policy) && ! isScriptURL(input)) {\n\t\treturn policy.createScriptURL(input);\n\t} else {\n\t\treturn input;\n\t}\n}\n\nexport function createPolicy(name, {\n\tcreateHTML = () => {\n\t\tthrow new TypeError('This policy does not provide `createHTML()`');\n\t},\n\tcreateScript = () => {\n\t\tthrow new TypeError('This policy does not provide `createScript()`');\n\t},\n\tcreateScriptURL = () => {\n\t\tthrow new TypeError('This policy does not provide `createScriptURL()`');\n\t},\n}) {\n\tif (supported()) {\n\t\treturn trustedTypes.createPolicy(name, { createHTML, createScript, createScriptURL });\n\t} else {\n\t\treturn Object.freeze({\n\t\t\tname,\n\t\t\tcreateHTML: (input, ...args) => createHTML(input.toString(), ...args),\n\t\t\tcreateScript: (input, ...args) => createScript(input.toString(), ...args),\n\t\t\tcreateScriptURL: (input, ...args) => createScriptURL(input.toString(), ...args),\n\t\t});\n\t}\n}\n\nexport function getDefaultPolicy() {\n\tif (supported()) {\n\t\treturn trustedTypes.defaultPolicy;\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport const createHTMLPolicyGetter = (name, cb) => callOnce(() => createPolicy(name, { createHTML: cb }));\n\nexport const createScriptPolicyGetter = (name, cb) => callOnce(() => createPolicy(name, { createScript: cb }));\n\nexport const createScriptURLPolicyGetter = (name, cb) => callOnce(() => createPolicy(name, { createScriptURL: cb }));\n","/**\n * @copyright 2023 Chris Zuber <admin@kernvalley.us>\n */\nimport { randomInt } from './math.js';\nimport { isAsyncFunction, getDeferred } from './promises.js';\nimport { isScriptURL, isTrustPolicy } from './trust.js';\n\nconst funcs = new WeakMap();\n\nexport function isStrictMode() {\n\t// Probably always true\n\treturn typeof this === 'undefined';\n}\n\nexport const autoServiceWorkerRegistration = callOnce(async ({\n\tpolicy = 'trustedTypes' in globalThis ? trustedTypes.defaultPolicy : null,\n} = {}) => {\n\tif ('serviceWorker' in navigator && 'serviceWorker' in document.documentElement.dataset) {\n\t\tconst { serviceWorker, scope = '/', updateViaCache } = document.documentElement.dataset;\n\n\t\ttry {\n\t\t\tif (isTrustPolicy(policy)) {\n\t\t\t\tawait registerServiceWorker(policy.createScriptURL(serviceWorker), { scope, updateViaCache });\n\t\t\t} else {\n\t\t\t\tawait registerServiceWorker(serviceWorker, { scope, updateViaCache });\n\t\t\t}\n\n\t\t\tawait reloadOnUpdate();\n\t\t} catch(err) {\n\t\t\tconsole.error(err);\n\t\t}\n\t}\n});\n\nexport async function reloadOnUpdate() {\n\tif ('serviceWorker' in navigator && 'reloadOnUpdate' in document.documentElement.dataset) {\n\t\tconst reg = await navigator.serviceWorker.ready;\n\n\t\treg.addEventListener('updatefound', async ({ target }) => {\n\t\t\ttarget.update();\n\n\t\t\tconst HTMLNotificationElement = await customElements.whenDefined('html-notification');\n\t\t\tconst notification = new HTMLNotificationElement('Update available', {\n\t\t\t\tbody: 'App updated in background. Would you like to reload to see updates?',\n\t\t\t\trequireInteraction: true,\n\t\t\t\tactions: [{\n\t\t\t\t\ttitle: 'Reload',\n\t\t\t\t\taction: 'reload',\n\t\t\t\t}, {\n\t\t\t\t\ttitle: 'Dismiss',\n\t\t\t\t\taction: 'dismiss',\n\t\t\t\t}]\n\t\t\t});\n\n\t\t\tnotification.addEventListener('notificationclick', ({ target, action }) => {\n\t\t\t\tswitch(action) {\n\t\t\t\t\tcase 'dismiss':\n\t\t\t\t\t\ttarget.close();\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'reload':\n\t\t\t\t\t\ttarget.close();\n\t\t\t\t\t\tlocation.reload();\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport async function registerServiceWorker(source, {\n\tscope,\n\tpolicy = 'trustedTypes' in globalThis ? trustedTypes.defaultPolicy : null,\n\ttype = 'classic',\n\tupdateViaCache = 'none',\n} = {}) {\n\tconst { resolve, reject, promise } = getDeferred();\n\n\tif (! ('serviceWorker' in navigator && navigator.serviceWorker.register instanceof Function)) {\n\t\treject(new DOMException('Service worker not supported'));\n\t} else if (! (typeof source === 'string' || isScriptURL(source) || source instanceof URL)) {\n\t\treject(new TypeError('Invalid Service worker registration source'));\n\t} else if (! isScriptURL(source) && isTrustPolicy(policy)) {\n\t\tnavigator.serviceWorker.register(\n\t\t\tpolicy.createScriptURL(source),\n\t\t\t{ scope, type, updateViaCache }\n\t\t).then(resolve).catch(reject);\n\t} else {\n\t\tnavigator.serviceWorker.register(source, { scope, type, updateViaCache })\n\t\t\t.then(resolve).catch(reject);\n\t}\n\n\treturn await promise;\n}\n\nexport function getURLResolver({ base = document.baseURI, path = './' } = {}) {\n\tconst url = new URL(path, base);\n\n\treturn path => new URL(path, url).href;\n}\n\nexport function isObject(thing) {\n\treturn typeof thing === 'object' && ! Object.is(thing, null) && ! Array.isArray(thing);\n}\n\nexport function isNull(val) {\n\treturn Object.is(val, null);\n}\n\nexport function isUndefined(val) {\n\treturn typeof val === 'undefined';\n}\n\nexport function isNullish(val) {\n\tswitch (typeof val) {\n\t\tcase 'undefined':\n\t\t\treturn true;\n\n\t\tcase 'object':\n\t\t\tif (Object.is(val, null)) {\n\t\t\t\treturn true;\n\t\t\t} else if (Array.isArray(val)) {\n\t\t\t\treturn val.length === 0;\n\t\t\t} else if (val instanceof Date) {\n\t\t\t\treturn Number.isNaN(val.getTime());\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\tcase 'number':\n\t\t\treturn Number.isNaN(val);\n\n\t\tcase 'string':\n\t\t\treturn val.length === 0;\n\n\t\tdefault:\n\t\t\treturn false;\n\t}\n}\n\nexport function getType(thing) {\n\tswitch (typeof thing) {\n\t\tcase 'undefined':\n\t\t\treturn 'Undefined';\n\n\t\tcase 'function':\n\t\t\tif ('prototype' in thing) {\n\t\t\t\treturn getType(thing.prototype);\n\t\t\t} else if ('constructor' in thing) {\n\t\t\t\treturn thing.constructor.name;\n\t\t\t} else {\n\t\t\t\treturn 'Function';\n\t\t\t}\n\n\t\tcase 'object':\n\t\t\tif (Object.is(thing, null)) {\n\t\t\t\treturn 'Null';\n\t\t\t} else if ('constructor' in thing) {\n\t\t\t\treturn thing.constructor.name;\n\t\t\t} else if (Symbol.toStringTag in thing) {\n\t\t\t\treturn thing[Symbol.toStringTag];\n\t\t\t} else if ('prototype' in thing) {\n\t\t\t\treturn  getType(thing.prototype);\n\t\t\t} else {\n\t\t\t\tconsole.log(thing);\n\t\t\t\treturn 'Unknown Object';\n\t\t\t}\n\n\t\tcase 'string':\n\t\t\treturn 'String';\n\n\t\tcase 'number':\n\t\t\treturn Number.isNaN(thing) ? 'NaN' : 'Number';\n\n\t\tcase 'bigint':\n\t\t\treturn 'BigInt';\n\n\t\tcase 'boolean':\n\t\t\treturn 'Boolean';\n\n\t\tcase 'symbol':\n\t\t\treturn 'Symbol';\n\n\t\tdefault:\n\t\t\treturn 'Unknown';\n\t}\n}\n\nexport function isA(thing, expectedType) {\n\tif (typeof expectedType === 'string') {\n\t\treturn getType(thing) === expectedType;\n\t} else if (isObject(expectedType) && 'constructor' in expectedType) {\n\t\treturn isA(thing, expectedType.constructor.name);\n\t} else {\n\t\tthrow new TypeError('Invalid argument for `expectedType`');\n\t}\n}\n\nexport function sameType(thing1, thing2) {\n\treturn isA(thing1, getType(thing2));\n}\n\nexport function deepEquals(thing1, thing2, { depth = 5 } = {}) {\n\tconst type1 = getType(thing1);\n\tconst type2 = getType(thing2);\n\n\tif (! Number.isSafeInteger(depth)) {\n\t\tthrow new TypeError('`depth` must be an integer');\n\t} else if (type1 !== type2) {\n\t\treturn false;\n\t} else if (thing1 === thing2) {\n\t\treturn true;\n\t} else {\n\t\tdepth--;\n\t\tswitch(type1) {\n\t\t\tcase 'NaN':\n\t\t\t\t// Since NaN !== NaN\n\t\t\t\treturn true;\n\n\t\t\tcase 'BigInt':\n\t\t\tcase 'Number':\n\t\t\tcase 'String':\n\t\t\tcase 'Symbol':\n\t\t\tcase 'Boolean':\n\t\t\t\t// Already know not equal\n\t\t\t\treturn false;\n\n\t\t\tcase 'Object':\n\t\t\t\treturn depth < 0 || deepEquals(Object.entries(thing1), Object.entries(thing2), { depth });\n\n\t\t\tcase 'Array':\n\t\t\t\treturn depth < 0 || (\n\t\t\t\t\tthing1.length === thing2.length\n\t\t\t\t\t&& thing1.every((thing, i) => deepEquals(thing, thing2[i], { depth }))\n\t\t\t\t);\n\n\t\t\tcase 'Map':\n\t\t\tcase 'Set':\n\t\t\t\treturn depth < 0 || deepEquals([...thing1], [...thing2], { depth });\n\n\t\t\tcase 'URL':\n\t\t\t\treturn thing1.href === thing2.href;\n\n\t\t\tdefault:\n\t\t\t\tif (thing1 instanceof Node) {\n\t\t\t\t\treturn thing1.isSameNode(thing2);\n\t\t\t\t} else if (Symbol.iterator in thing1) {\n\t\t\t\t\treturn depth < 0 || deepEquals([...thing1], [...thing2], { depth });\n\t\t\t\t} else {\n\t\t\t\t\t// Since already not `===`\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t}\n\t}\n}\n\n/* global define */\nexport function amd(name, factory, requires = {}) {\n\tif (typeof define === 'function' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\ttry {\n\t\t\tdefine(name, requires, factory);\n\t\t\treturn true;\n\t\t} catch(err) {\n\t\t\tconsole.error(err);\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\treturn false;\n\t}\n}\n\nexport function errorToEvent(error, type = 'error') {\n\tif (error instanceof Error) {\n\t\tconst { message, name, fileName: filename, lineNumber: lineno, columnNumber: colno } = error;\n\t\treturn new ErrorEvent(type, { error, message: `${name}: ${message}`, filename, lineno, colno });\n\t} else {\n\t\tthrow new TypeError('`errorToEvent()` only accepts Errors');\n\t}\n}\n\n\nexport function callOnce(callback, thisArg) {\n\tif (callback.once instanceof Function) {\n\t\treturn callback.once(thisArg);\n\t} else {\n\t\treturn function(...args) {\n\t\t\tif (funcs.has(callback)) {\n\t\t\t\treturn funcs.get(callback);\n\t\t\t} else if (isAsyncFunction(callback)) {\n\t\t\t\tconst retVal = callback.apply(thisArg || this, args).catch(err => {\n\t\t\t\t\tfuncs.delete(callback);\n\t\t\t\t\tthrow err;\n\t\t\t\t});\n\n\t\t\t\tfuncs.set(callback, retVal);\n\t\t\t\treturn retVal;\n\t\t\t} else if (callback instanceof Function) {\n\t\t\t\tconst retVal = callback.apply(thisArg || this, args);\n\t\t\t\tfuncs.set(callback, retVal);\n\t\t\t\treturn retVal;\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport function setURLParams(forURL, params) {\n\tconst url = new URL(forURL, document.baseURI);\n\n\tif (params instanceof HTMLFormElement) {\n\t\treturn setURLParams(url, new FormData(params));\n\t} else if (params instanceof FormData) {\n\t\treturn setURLParams(url, Object.fromEntries(params));\n\t} else if (params instanceof URLSearchParams) {\n\t\treturn setURLParams(url, Object.fromEntries(params));\n\t} else if (Array.isArray(params) || typeof params === 'string') {\n\t\treturn setURLParams(url, new URLSearchParams(params));\n\t} else if (isObject(params)) {\n\t\tObject.entries(params).forEach(([k, v]) => {\n\t\t\tif (typeof v === 'string' || (typeof v === 'number' && ! Number.isNaN(v))) {\n\t\t\t\turl.searchParams.set(k, v);\n\t\t\t} else if (typeof v === 'boolean') {\n\t\t\t\tif (v) {\n\t\t\t\t\turl.searchParams.set(k, '');\n\t\t\t\t} else {\n\t\t\t\t\turl.searchParams.delete(k);\n\t\t\t\t}\n\t\t\t} else if (! isNullish(v)) {\n\t\t\t\turl.searchParams.set(k, v.toString());\n\t\t\t}\n\t\t});\n\t}\n\n\treturn url;\n}\n\nexport function setUTMParams(url, {\n\tsource: utm_source,\n\tmedium: utm_medium = 'referral',\n\tcontent: utm_content,\n\tcampaign: utm_campaign,\n\tterm: utm_term,\n} = {}) {\n\tif (isNullish(url)) {\n\t\treturn null;\n\t} else if (! (url instanceof URL)) {\n\t\treturn setUTMParams(new URL(url, document.baseURI), {\n\t\t\tsource: utm_source,\n\t\t\tmedium: utm_medium,\n\t\t\tcontent: utm_content,\n\t\t\tcampaign: utm_campaign,\n\t\t\tterm: utm_term,\n\t\t});\n\t} else if (typeof utm_source !== 'string') {\n\t\treturn url;\n\t} else {\n\t\treturn setURLParams(url, { utm_source, utm_medium, utm_content, utm_campaign, utm_term });\n\t}\n}\n\nexport function debounce(callback, { delay = 17, thisArg } = {}) {\n\tif (! (callback instanceof Function)) {\n\t\tthrow new TypeError('Callback must be a function');\n\t} else if (! Number.isFinite(delay) || delay < 0) {\n\t\tthrow new TypeError('Timeout must be a positive intiger');\n\t} else {\n\t\tlet to;\n\t\treturn function(...args) {\n\t\t\tif (typeof to === 'number') {\n\t\t\t\tclearTimeout(to);\n\t\t\t\tto = null;\n\t\t\t}\n\t\t\tto = setTimeout((...args) => callback.apply(thisArg, args), delay, ...args);\n\t\t};\n\t}\n}\n\nexport function throttle(callback, { delay = 17, thisArg } = {}) {\n\tif (! (callback instanceof Function)) {\n\t\tthrow new TypeError('Callback must be a function');\n\t} else if (! Number.isFinite(delay) || delay < 0) {\n\t\tthrow new TypeError('Timeout must be a positive intiger');\n\t} else {\n\t\tlet to;\n\t\treturn function(...args) {\n\t\t\tif (typeof to !== 'number') {\n\t\t\t\tto = setTimeout(() => to = null, delay);\n\t\t\t\tcallback.apply(thisArg, args);\n\t\t\t}\n\t\t};\n\t}\n}\n\nexport function random(arr) {\n\tif (Array.isArray(arr) && arr.length !== 0) {\n\t\treturn arr[randomInt(0, arr.length)];\n\t}\n}\n\nexport const toSpinalCase = str => str.replace(/[A-Z]/g, (m, i) => i === 0\n\t? m.toLowerCase()\n\t: `-${m.toLowerCase()}`);\n\nexport const toCamelCase = str => str.replace(/-[a-z\\d]/g, m => m.substr(1).toUpperCase());\n\nexport const ucFirst = str => str.substr(0, 1).toUpperCase() + str.substr(1);\n","import { when } from './dom.js';\nimport { signalAborted } from './abort.js';\nimport { listen, onKeypress } from './events.js';\nimport { checkSupport as locksSupported } from './LockManager.js';\nexport const infinitPromise = new Promise(() => {});\n\n//export const readyPromise = ready();\n\n//export const loadedPromise = loaded();\n\n// export const manifestPromise = new Promise((resolve, reject) => {\n// \tready().then(() => getManifest()).then(resolve).catch(reject);\n// });\n\n// export const beforeInstallPromptPromise = beforeInstallPrompt();\n\nexport function isAsyncFunction(what) {\n\treturn what instanceof Function && what.constructor.name === 'AsyncFunction';\n}\n\nexport function isAsync(what) {\n\treturn isAsyncFunction(what) || what instanceof  Promise;\n}\n\nexport function getDeferred({ signal } = {}) {\n\tconst deferred = {};\n\n\tdeferred.promise = new Promise((resolve, reject) => {\n\t\tdeferred.resolve = resolve;\n\t\tdeferred.reject = reject;\n\t});\n\n\tif (signal instanceof EventTarget && signal.throwIfAborted instanceof Function) {\n\t\tif (signal.aborted) {\n\t\t\tdeferred.reject(signal.reason);\n\t\t} else {\n\t\t\tsignal.addEventListener('abort', ({ target }) => deferred.reject(target.reason), { once: true });\n\t\t}\n\t}\n\n\treturn Object.seal(deferred);\n}\n\nexport async function callAsAsync(callback, args = [], { thisArg = globalThis, signal } = {}) {\n\tconst { promise, resolve, reject } = getDeferred({ signal });\n\n\tif (! (callback instanceof Function)) {\n\t\treject(new TypeError('`callAsAsync` expects callback to be a function'));\n\t} else if (! Array.isArray(args)) {\n\t\treject(new TypeError('`args` must be an array'));\n\t} else if (signal instanceof AbortSignal && signal.aborted) {\n\t\treject(signal.reason);\n\t} else if (isAsyncFunction(callback)) {\n\t\tcallback.call(thisArg, args).then(resolve).catch(reject);\n\t} else {\n\t\tqueueMicrotask(() => {\n\t\t\ttry {\n\t\t\t\tresolve(callback.call(thisArg, args));\n\t\t\t} catch(err) {\n\t\t\t\treject(err);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn await promise;\n}\n\nexport async function whenKeypress(key, {\n\ttarget = globalThis,\n\ttype = 'keypress',\n\tcapture,\n\tpassive,\n\tsignal,\n\taltKey,\n\tctrlKey,\n\tmetaKey,\n\tshiftKey,\n} = {}) {\n\tconst { resolve, promise } = getDeferred({ signal });\n\tonKeypress(key, resolve, { target, type, capture, once: true, passive, signal, altKey, ctrlKey, metaKey, shiftKey });\n\treturn await promise;\n}\n\nexport function createDeferredCallback(callback, { signal, thisArg } = {}) {\n\tconst { promise, resolve } = getDeferred({ signal });\n\tconst retPromise = promise.then(() => callAsAsync(callback, [], { signal, thisArg }));\n\n\treturn async () => {\n\t\tresolve();\n\t\treturn await retPromise;\n\t};\n}\n\nexport async function lock(name, callback, {\n\tthisArg = globalThis,\n\targs = [],\n\tmode = 'exclusive',\n\tifAvailable = false,\n\tsteal = false,\n\tallowFallback = true,\n\tsignal,\n} = {}) {\n\tif ((! allowFallback) || await locksSupported()) {\n\t\treturn await navigator.locks.request(name, { mode, ifAvailable, steal, signal }, async lock => {\n\t\t\tif (lock) {\n\t\t\t\treturn await callAsAsync(callback, [lock, ...args], { thisArg, signal });\n\t\t\t}\n\t\t});\n\t} else {\n\t\treturn await callAsAsync(callback, [null, ...args], { signal, thisArg });\n\t}\n}\n\nexport async function onAnimationFrame(callback, {\n\tthisArg = globalThis,\n\targs = [],\n\tsignal,\n} = {}) {\n\tconst { promise, resolve, reject } = getDeferred({ signal });\n\tconst id = requestAnimationFrame(hrts => callAsAsync(callback, [hrts, ...args], { signal, thisArg }).then(resolve, reject));\n\n\tif (signal instanceof AbortSignal) {\n\t\tsignalAborted(signal).finally(() => cancelAnimationFrame(id));\n\t}\n\n\treturn await promise;\n}\n\nexport async function onIdle(callback, {\n\ttimeout,\n\tthisArg = globalThis,\n\targs = [],\n\tsignal,\n} = {}) {\n\tconst { promise, resolve, reject } = getDeferred({ signal });\n\tconst id = requestIdleCallback(hrts => callAsAsync(callback, [hrts, ...args], { thisArg, signal }).then(resolve, reject), { timeout });\n\n\tif (signal instanceof AbortSignal) {\n\t\tsignalAborted(signal).finally(() => cancelIdleCallback(id));\n\t}\n\n\treturn await promise;\n}\n\nexport async function onTimeout(callback, {\n\ttimeout = 0,\n\tthisArg = globalThis,\n\targs = [],\n\tsignal,\n} = {}) {\n\tconst { resolve, reject, promise } = getDeferred({ signal });\n\n\tif (Number.isSafeInteger(timeout) && timeout >= 0) {\n\t\tconst id = setTimeout(() => {\n\t\t\tcallAsAsync(callback, args, { signal, thisArg }).then(resolve).catch(reject);\n\t\t}, timeout);\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignalAborted(signal).finally(() => clearTimeout(id));\n\t\t}\n\t} else {\n\t\treject(new TypeError('`timeout` must be a positive intege'));\n\t}\n\n\treturn await promise;\n}\n\nexport async function sleep(timeout, { signal } = {}) {\n\tconst { resolve, promise } = getDeferred({ signal });\n\tonTimeout(() => resolve(performance.now()), { signal, timeout })\n\t\t.catch(() => resolve(performance.now()));\n\treturn await promise;\n}\n\nexport async function promisifyEvents(targets, { success, fail = 'error', passive = true, capture = true } = {}) {\n\tconst controller = new AbortController();\n\tconst opts = { passive, capture, signal: controller.signal, once: true };\n\n\ttry {\n\t\tconst events = [];\n\n\t\tif (typeof success === 'string' || Array.isArray(success) && success.length !== 0) {\n\t\t\tevents.push(when(targets, success, opts));\n\t\t}\n\n\t\tif (typeof fail === 'string' || (Array.isArray(fail) && fail.length !== 0)) {\n\t\t\tevents.push(when(targets, fail, opts).then(event => Promise.reject(event)));\n\t\t}\n\n\t\tconst result = await Promise.race(events);\n\n\t\tcontroller.abort();\n\t\treturn result;\n\t} catch(err) {\n\t\tcontroller.abort();\n\t\tthrow err;\n\t}\n}\n\nexport async function *promiseQueue(...promises) {\n\tconst target = new EventTarget();\n\tconst queue = new Set(promises);\n\tconst results = [];\n\n\tpromises.forEach(prom => prom.then(result => {\n\t\tresults.push(result);\n\t\tqueue.delete(prom);\n\t\ttarget.dispatchEvent(new Event('resolve'));\n\t}));\n\n\twhile (queue.size !== 0 || results.length !== 0) {\n\t\tif (results.length === 0) {\n\t\t\tawait resolveOn(target, 'resolve');\n\t\t}\n\n\t\tyield results.shift();\n\t}\n}\n\nexport async function resolveOn(targets, success, { passive = true, capture = true } = {}) {\n\treturn await promisifyEvents(targets, { success, fail: null,  passive, capture });\n}\n\nexport async function rejectOn(targets, fail, { passive = true, capture = true } = {}) {\n\treturn await promisifyEvents(targets, { success: null, fail,  passive, capture });\n}\n\nexport async function abortablePromise(promise, signal) {\n\treturn await Promise.race([promise, signalAborted(signal)]);\n}\n\nexport async function *eventGenerator(target, event, { signal, capture, passive } = {}) {\n\tconst { callback, generator } = callbackGenerator();\n\tlisten(target, event, callback, { signal, capture, passive });\n\n\tif (! (signal instanceof AbortSignal)) {\n\t\tfor await (const result of generator()) {\n\t\t\tyield await result;\n\t\t}\n\t} else if (signal.aborted) {\n\t\treturn;\n\t} else {\n\t\tfor await (const result of generator({ signal })) {\n\t\t\tyield await result;\n\t\t}\n\t}\n}\n\nexport function callbackGenerator() {\n\tconst target = new EventTarget();\n\tconst queue = [];\n\n\tasync function *generator({ signal } = {}) {\n\t\tif (signal instanceof AbortSignal) {\n\t\t\twhile (! signal.aborted) {\n\t\t\t\tif (queue.length === 0) {\n\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\twhen(target, 'update', { signal }),\n\t\t\t\t\t\tsignalAborted(signal).catch(() => null).finally(() => null),\n\t\t\t\t\t]).catch(() => null);\n\t\t\t\t}\n\n\t\t\t\tyield queue.shift();\n\t\t\t}\n\t\t} else {\n\t\t\twhile (true) {\n\t\t\t\tif (queue.length === 0) {\n\t\t\t\t\tawait when(target, 'update', { signal });\n\t\t\t\t}\n\n\t\t\t\tyield queue.shift();\n\t\t\t}\n\t\t}\n\t}\n\n\tconst callback = (...args) => {\n\t\tqueue.push(...args);\n\t\ttarget.dispatchEvent(new Event('update'));\n\t};\n\n\treturn { callback, generator };\n}\n","import { query, when } from './dom.js';\nimport { signalAborted } from './abort.js';\nimport { getDeferred } from './promises.js';\nimport { debounce as db, throttle } from './utility.js';\n\nexport async function loaded(target, {\n\tsignal: passedSignal,\n\tsuccess = 'load',\n\terror = 'error',\n} = {}) {\n\treturn await new Promise(async (resolve, reject) => {\n\t\tif (passedSignal instanceof AbortSignal && passedSignal.aborted) {\n\t\t\treject(passedSignal.reason);\n\t\t} else if (target instanceof HTMLScriptElement && target.noModule && HTMLScriptElement.supports('module')) {\n\t\t\t/**\n\t\t\t * <script nomodule> will never load\n\t\t\t */\n\t\t\tresolve(target);\n\t\t} else if (target instanceof HTMLLinkElement && target.disabled) {\n\t\t\t/**\n\t\t\t * <link disabled> will never load\n\t\t\t */\n\t\t\tresolve(target);\n\t\t} else if (target instanceof HTMLImageElement && target.loading === 'lazy' && !(target.parentElement instanceof Element)) {\n\t\t\t/**\n\t\t\t * <img loading=\"lazy\"> will not load until appended\n\t\t\t */\n\t\t\tresolve(target);\n\t\t} else if (target instanceof HTMLImageElement && target.decode instanceof Function) {\n\t\t\tawait target.decode();\n\t\t\treturn target;\n\t\t} else {\n\t\t\tconst controller = new AbortController();\n\t\t\tconst signal = passedSignal instanceof AbortSignal ? AbortSignal.any([\n\t\t\t\tpassedSignal,\n\t\t\t\tcontroller.signal,\n\t\t\t]) : passedSignal;\n\n\t\t\tlisten(target, success, ({ target }) => {\n\t\t\t\tresolve(target);\n\t\t\t\tcontroller.abort();\n\t\t\t}, { once: true, signal });\n\n\t\t\tlisten(target, error, ({ target: { tagName, src, href} }) => {\n\t\t\t\tconst error = new Error(`Failed to load <${tagName.toLowerCase()}>`, {\n\t\t\t\t\tcause: new Error(`Request to ${src || href} failed`),\n\t\t\t\t});\n\n\t\t\t\treject(error);\n\t\t\t\tcontroller.abort(error);\n\t\t\t}, { once: true, signal });\n\n\t\t\tif (passedSignal instanceof AbortSignal) {\n\t\t\t\tlisten(passedSignal, 'abort', ({ target: { reason }}) => {\n\t\t\t\t\tif (! controller.signal.aborted) {\n\t\t\t\t\t\treject(reason);\n\t\t\t\t\t\tcontroller.abort(reason);\n\t\t\t\t\t}\n\t\t\t\t}, { once: true, signal: controller.signal });\n\t\t\t}\n\t\t}\n\t});\n}\n\nexport function getEventFeatures() {\n\tconst el = document.createElement('div');\n\tconst eventFeatures = {\n\t\tnativeSignal: 'AbortController' in globalThis && AbortController.prototype.hasOwnProperty('signal'),\n\t\tsignal: false,\n\t\tpassive: false,\n\t\tcapture: false,\n\t\tonce: false,\n\t};\n\n\t// Use of a getter will detect support when properties are read\n\tconst options = {\n\t\tget passive() {\n\t\t\teventFeatures.passive = true;\n\t\t\treturn undefined;\n\t\t},\n\t\tget signal() {\n\t\t\teventFeatures.signal = true;\n\t\t\treturn undefined;\n\t\t},\n\t\tget capture() {\n\t\t\teventFeatures.capture = true;\n\t\t\treturn undefined;\n\t\t},\n\t\tget once() {\n\t\t\teventFeatures.once = true;\n\t\t\treturn undefined;\n\t\t},\n\t};\n\n\ttry {\n\t\tel.addEventListener('click', null, options);\n\t\tel.removeEventListener('click', null, options);\n\t} catch(err) {\n\t\tconsole.error(err);\n\t}\n\n\treturn Object.seal(eventFeatures);\n}\n\nexport const features = getEventFeatures();\n\nexport function addListener(targets, events, callback, { capture, once, passive, signal } = {}) {\n\tif (! Array.isArray(targets)) {\n\t\ttargets = query(targets);\n\t}\n\n\tif (! Array.isArray(events)) {\n\t\tevents = Array.of(events);\n\t}\n\n\ttargets.forEach(target => {\n\t\tevents.forEach(event => listen(target, event, callback, { capture, once, passive, signal }));\n\t});\n}\n\nexport function listen(target, event, callback, { capture, once, passive, signal } = {}) {\n\tif (! (signal instanceof EventTarget && signal.aborted)) {\n\t\ttarget.addEventListener(event, callback, { capture, once, passive, signal });\n\n\t\tif (features.signal === false && signal instanceof EventTarget) {\n\t\t\tsignalAborted(signal).finally(() => target.removeEventListener(event, callback, { capture, once, passive, signal }));\n\t\t}\n\t}\n}\n\nexport function onKeypress(key, callback, {\n\ttarget = globalThis,\n\ttype = 'keypress',\n\tcapture,\n\tonce,\n\tpassive,\n\tsignal,\n\taltKey,\n\tctrlKey,\n\tmetaKey,\n\tshiftKey,\n} = {}) {\n\tlisten(target, type, function handler(event) {\n\t\tif (\n\t\t\tevent.isTrusted && event.key.toLowerCase() === key.toLowerCase()\n\t\t\t&& Object.entries({ ctrlKey, altKey, shiftKey, metaKey }).every(([name, value]) => {\n\t\t\t\treturn typeof value !== 'boolean' || event[name] === value;\n\t\t\t})) {\n\t\t\tif (once) {\n\t\t\t\ttarget.removeEventListener(type, handler, { passive, capture, signal });\n\t\t\t}\n\n\t\t\tcallback.call(this, event);\n\t\t}\n\t}, { passive, capture, signal });\n}\n\nexport async function once(target, event, { capture, passive, signal } = {}) {\n\tconst { resolve, promise } = getDeferred({ signal, reason: new DOMException('Operation aborted') });\n\tlisten(target, event, resolve, { capture, once: true, passive, signal });\n\treturn await promise;\n}\n\nexport function removeListener(targets, events, callback, { capture, once, passive, signal } = {}) {\n\tif (! Array.isArray(targets)) {\n\t\ttargets = query(targets);\n\t}\n\n\tif (! Array.isArray(events)) {\n\t\tevents = Array.of(events);\n\t}\n\n\ttargets.forEach(target => {\n\t\tevents.forEach(event => target.removeEventListener(event, callback, { capture, once, passive, signal }));\n\t});\n}\n\n/**\n * Control the execution rate of callbacks, i.e. for listeners\n * https://davidwalsh.name/function-debounce\n *\n * @param  Callable callback    The callback\n * @param  int      [ms]        Number of milliseconds, defaulting to 1/60th a second\n * @param  bool     [immediate] Trigger function immediately instead of after wait ms\n * @return function             Rate limited function\n */\nexport function debounce(func, wait = 17, immediate = false) {\n\tconsole.warn('debounce() in events.js is deprecated. Please use utility.js instead.');\n\treturn immediate ? throttle(func, { delay: wait }): db(func, { delay: wait });\n}\n\nexport async function whenOnline({ signal } = {}) {\n\tif (navigator.onLine === false) {\n\t\tawait when(window, 'online', { signal });\n\t}\n}\n\nexport async function whenOffline({ signal } = {}) {\n\tif (navigator.onLine === true) {\n\t\tawait when(window, 'offline', { signal });\n\t}\n}\n\nexport async function whenVisible({ signal } = {}) {\n\tif (document.visibilityState === 'hidden') {\n\t\tawait when(document, 'visibilitychange', { signal });\n\t}\n}\n\nexport async function whenHidden({ signal } = {}) {\n\tif (document.visibilityState === 'visible') {\n\t\tawait when(document, 'visibilitychange', { signal });\n\t}\n}\n","import { when, beforeUnload, unloaded } from './dom.js';\nimport { getDeferred } from './promises.js';\nimport { listen } from './events.js';\nexport const supported =  'AbortController' in window && AbortController.prototype.hasOwnProperty('signal');\n\nexport function throwIfAborted(signal) {\n\tif (signal instanceof AbortController) {\n\t\tsignal.signal.throwIfAborted();\n\t} else if (signal instanceof AbortSignal) {\n\t\tsignal.throwIfAborted();\n\t}\n}\n\nexport function getBeforeUnloadSignal() {\n\tconst controller = new AbortController();\n\tbeforeUnload().then(() => controller.abort());\n\treturn controller.signal;\n}\n\nexport function getUnloadSignal() {\n\tconst controller = new AbortController();\n\tunloaded().then(() => controller.abort());\n\treturn controller.signal;\n}\n\nexport function isAborted(signal) {\n\tif (signal instanceof AbortController) {\n\t\treturn signal.signal.aborted;\n\t} else {\n\t\treturn signal instanceof AbortSignal && signal.aborted;\n\t}\n}\n\nexport async function signalAborted(signal) {\n\tconst { reject, promise } = getDeferred();\n\n\tif (signal instanceof AbortController) {\n\t\treturn signalAborted(signal.signal);\n\t} else if (! (signal instanceof EventTarget)) {\n\t\treject(new DOMException('Not an AbortSignal'));\n\t} else if (signal.aborted) {\n\t\treject(signal.reason);\n\t} else {\n\t\tsignal.addEventListener('abort', ({ target }) => reject(target.reason),{ once: true });\n\t}\n\n\treturn promise;\n}\n\nexport function abortButtonController(button, { reason } = {}) {\n\tif (! (button instanceof HTMLButtonElement)) {\n\t\tthrow new TypeError('Not a <button>');\n\t}\n\n\tconst controller = new AbortController();\n\tbutton.disabled = false;\n\n\tlisten(button, 'click', () => controller.abort(reason), { signal: controller.signal, once: true });\n\tlisten(controller.signal, 'abort', () => button.disabled = true, { once: true });\n\n\treturn controller;\n}\n\n/**\n * @deprecated\n */\nexport function abortTimeoutController(timeout, { reason } = {}) {\n\tconsole.warn('`abortTimeoutController()` is deprecated. Use `AbortSignal.timeout()` instead.');\n\tconst controller = new AbortController();\n\n\tabortableTimeout(() => controller.abort(reason), timeout, { signal: controller.signal });\n\n\treturn controller;\n}\n\n/**\n * @deprecated\n */\nexport function abortTimeoutSignal(timeout, { reason } = {}) {\n\treturn abortTimeoutController(timeout, { reason }).signal;\n}\n\nexport function abortEventController(what, events, { passive, capture, reason } = {}) {\n\tconst controller = new AbortController();\n\n\twhen(what, events, { signal: controller.signal, capture, passive, once: true }).then(() => {\n\t\tif (! controller.signal.aborted) {\n\t\t\tcontroller.abort(reason);\n\t\t}\n\t});\n\n\treturn controller;\n}\n\nexport function abortableTimeout(callback, ms, { signal } = {}) {\n\tconst id = setTimeout(() => callback(), ms);\n\n\tif (signal instanceof AbortSignal) {\n\t\tsignalAborted(signal).finally(() => clearTimeout(id));\n\t}\n\n\treturn id;\n}\n\nexport function abortableInterval(callback, ms, { signal } = {}) {\n\tconst id = setInterval(() => callback(), ms);\n\n\tif (signal instanceof AbortSignal) {\n\t\tsignalAborted(signal).finally(() => clearInterval(id));\n\t}\n\n\treturn id;\n}\n\nexport function abortableAnimationFrame(callback, { signal } = {}) {\n\tconst id = requestAnimationFrame(callback);\n\n\tif (signal instanceof AbortSignal) {\n\t\tsignalAborted(signal).finally(() => cancelAnimationFrame(id));\n\t}\n\n\treturn id;\n}\n\nexport function abortableIdleCallback(callback, { signal, timeout } = {}) {\n\tconst id = requestIdleCallback(callback);\n\n\tif (signal instanceof AbortSignal) {\n\t\tsignalAborted(signal).finally(() => cancelIdleCallback(id, { timeout }));\n\t}\n\n\treturn id;\n}\n\nexport function signalRaceController(...signals) {\n\tconst controller = new AbortController();\n\tconst signal = anyAbortedSignal(...signals);\n\n\tsignal.addEventListener('abort', ({ target }) => {\n\t\tcontroller.abort(target.reason || new DOMException('Operation aborted.'));\n\t}, { signal: controller.signal });\n\n\treturn controller;\n}\n\nexport function signalAllController(...signals) {\n\tconst controller = new AbortController();\n\n\tPromise.all(signals.map(signal => signalAborted(signal))).finally(() => controller.abort());\n\n\treturn controller;\n}\n\nexport function anyAbortedSignal(...signals) {\n\tif (AbortSignal.any instanceof Function) {\n\t\treturn AbortSignal.any(signals);\n\t} else {\n\t\tconst controller = new AbortController();\n\n\t\tfor (const signal of signals) {\n\t\t\tif (! (signal instanceof AbortSignal)) {\n\t\t\t\tconst err = new TypeError('`signal` is not an `AbortSignal`');\n\t\t\t\tcontroller.abort(err);\n\t\t\t\tthrow err;\n\t\t\t} else if (signal.aborted) {\n\t\t\t\tcontroller.abort(signal.reason || new DOMException('Operation aborted.'));\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tsignal.addEventListener('abort', ({ target }) => {\n\t\t\t\t\tcontroller.abort(target.reason || new DOMException('Operation aborted.'));\n\t\t\t\t}, { signal: controller.signal });\n\t\t\t}\n\t\t}\n\n\t\treturn controller.signal;\n\t}\n}\n","const protectedData = new WeakMap();\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Lock\n */\nexport class Lock {\n\tconstructor(name, mode = 'exclusive') {\n\t\tif (! ['exclusive', 'shared'].includes(mode)) {\n\t\t\tthrow new TypeError(`'${mode}' (value of 'mode' member of LockOptions) is not a valid value for enumeration LockMode.`);\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tname = name.toString();\n\t\t}\n\n\t\tif (name.startsWith('-')) {\n\t\t\tthrow new DOMException('Names starting with `-` are reserved');\n\t\t}\n\n\t\tprotectedData.set(this, { name, mode });\n\t}\n\n\tget name() {\n\t\treturn protectedData.get(this).name;\n\t}\n\n\tget mode() {\n\t\treturn protectedData.get(this).mode;\n\t}\n}\n","import { getDeferred, isAsync } from './promises.js';\nimport { Lock } from './Lock.js';\nconst locks = new Map();\nconst symbols = {\n\tlockKey: Symbol('lock-key'),\n};\n\nexport const nativeSupport = 'locks' in navigator && navigator.locks.request instanceof Function;\nexport async function checkSupport() {\n\treturn await new Promise(resolve => {\n\t\tif ('locks' in navigator && navigator.locks.request instanceof Function) {\n\t\t\tnavigator.locks.query().then(() => resolve(true)).catch(() => resolve(false));\n\t\t} else {\n\t\t\tresolve(false);\n\t\t}\n\t});\n}\n/**\n * Some browsing contexts (iframes) have `navigator.locks` but methods only throw\n */\nexport const actuallySupported = checkSupport();\n\nasync function callFunction(callback, arg = null) {\n\treturn new Promise((resolve, reject) => {\n\t\tif (isAsync(callback)) {\n\t\t\tcallback.call(globalThis, arg).then(resolve, reject);\n\t\t} else {\n\t\t\tqueueMicrotask(() => {\n\t\t\t\ttry {\n\t\t\t\t\tconst result = callback.call(globalThis, arg);\n\t\t\t\t\tresolve(result);\n\t\t\t\t} catch(err) {\n\t\t\t\t\treject(err);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t});\n}\n\nfunction shouldPend({ name, mode }) {\n\tswitch(mode) {\n\t\tcase 'exclusive': return getLocks().some(lock => lock.name === name);\n\t\tcase 'shared': return getLocks().some(lock => lock.name === name && lock.mode === 'exclusive');\n\t}\n}\n\nfunction stealLocks(name) {\n\t[...locks.entries()].filter(([lock]) => lock.name === name).forEach(([lock, { reject, controller }]) => {\n\t\trequestIdleCallback(() => {\n\t\t\tcontroller.abort();\n\t\t\tlocks.delete(lock);\n\t\t});\n\t\treject(new DOMException('The lock request is aborted'));\n\t});\n}\n\nasync function whenReleased(lock) {\n\tif (locks.has(lock)) {\n\t\tawait locks.get(lock).promise.catch(console.error);\n\t}\n}\n\nfunction queueTask(name, mode, callback) {\n\tconst { resolve, reject, promise } = getDeferred();\n\tconst controller = new AbortController();\n\tconst lock = new Lock(name, mode);\n\tconst pending = shouldPend(lock);\n\tlocks.set(lock, { resolve, reject, promise, callback, pending, controller });\n\treturn lock;\n}\n\nfunction setPending(lock, pending = true) {\n\tif (locks.has(lock)) {\n\t\tlocks.set(lock, {...locks.get(lock), pending });\n\t}\n}\n\nfunction isPending(lock) {\n\treturn lock instanceof Lock && locks.has(lock) && locks.get(lock).pending;\n}\n\nfunction getLocks(name) {\n\tif (typeof name === 'string') {\n\t\treturn [...locks.keys()].filter(lock => lock.name === name);\n\t} else {\n\t\treturn [...locks.keys()];\n\t}\n}\n\nfunction getHeldLocks(name) {\n\treturn getLocks(name).filter(lock => ! isPending(lock));\n}\n\nfunction getPendingLocks(name) {\n\treturn getLocks(name).filter(lock => isPending(lock));\n}\n\nasync function whenNotBlocked(lock) {\n\tswitch(lock.mode) {\n\t\tcase 'exclusive':\n\t\t\tawait Promise.allSettled(getLocks()\n\t\t\t\t.filter(l => l.name === lock.name && l !== lock).map(whenReleased));\n\t\t\tbreak;\n\t\tcase 'shared':\n\t\t\tawait Promise.allSettled(getLocks()\n\t\t\t\t.filter(l => l.name === lock.name && l.mode === 'exclusive' && l !== lock).map(whenReleased));\n\t\t\tbreak;\n\t}\n}\n\nfunction getLockSignal(lock) {\n\tif (locks.has(lock)) {\n\t\treturn locks.get(lock).controller.signal;\n\t}\n}\n\nasync function executeLock(lock) {\n\tif (locks.has(lock)) {\n\t\tconst { resolve, reject, promise, callback, pending, controller } = locks.get(lock);\n\t\tif (pending) {\n\t\t\tsetPending(lock, false);\n\t\t}\n\n\t\tcallFunction(callback, lock).then(resolve, reject).finally(() => {\n\t\t\tlocks.delete(lock);\n\t\t\trequestIdleCallback(() => controller.abort());\n\t\t});\n\n\t\treturn promise;\n\t}\n}\n\n/**\n * @see https://w3c.github.io/web-locks/\n * @see https://developer.mozilla.org/en-US/docs/Web/API/LockManager\n */\nexport class LockManager {\n\tconstructor(key) {\n\t\tif (key !== symbols.lockKey) {\n\t\t\tthrow new TypeError('Invalid constructor');\n\t\t}\n\t}\n\t/**\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request\n\t * @param  {[type]}  name               [description]\n\t * @param  {[type]}  args               [description]\n\t * @return {Promise}      [description]\n\t * static async request(name, callback)\n\t * static async request(name, { mode = 'exclusive', ifAvailable = false, steal = false, signal }, callback)\n\t */\n\tstatic async request(name, ...args) {\n\t\tlet opts = {}, callback;\n\t\tif (args[0] instanceof Function) {\n\t\t\tcallback = args[0];\n\t\t} else if (args[1] instanceof Function) {\n\t\t\t[opts, callback] = args;\n\t\t}\n\n\t\tif (typeof name !== 'string') {\n\t\t\tname = name.toString();\n\t\t}\n\n\t\tconst { mode = 'exclusive', ifAvailable = false, steal = false, signal } = opts;\n\n\t\tif (steal && ifAvailable) {\n\t\t\tthrow new DOMException('LockManager.request: `steal` and `ifAvailable` cannot be used together');\n\t\t} else if (name.startsWith('-')) {\n\t\t\tthrow new DOMException('LockManager.request: Names starting with `-` are reserved');\n\t\t} else if (! ['exclusive', 'shared'].includes(mode)) {\n\t\t\tthrow new TypeError(`LockManager.request: '${mode}' (value of 'mode' member of LockOptions) is not a valid value for enumeration LockMode.`);\n\t\t} else if (signal instanceof AbortSignal && signal.aborted) {\n\t\t\tthrow signal.reason;\n\t\t} else if (mode === 'shared' && steal) {\n\t\t\tthrow new DOMException('LockManager.request: `steal` is only supported for exclusive lock requests');\n\t\t}\n\n\t\tconst held = getHeldLocks(name);\n\t\tconst pending = getPendingLocks(name);\n\t\tconst alreadyLocked = [...held, ...pending].some(lock => lock.name === name);\n\n\t\tif (steal && alreadyLocked) {\n\t\t\tstealLocks(name);\n\t\t}\n\n\t\t/**\n\t\t * If shared & held lock found (none exclusive), then this lock may be held as well\n\t\t * If exclusive & held or pending lock found, this is pending\n\t\t */\n\t\tconst lock = queueTask(name, mode, callback);\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignal.addEventListener('abort', () => {\n\t\t\t\tif (locks.has(lock)) {\n\t\t\t\t\tconst { reject, controller } = locks.get(lock);\n\t\t\t\t\tlocks.delete(lock);\n\t\t\t\t\treject(new DOMException('The lock request is aborted'));\n\t\t\t\t\tcontroller.abort();\n\t\t\t\t}\n\t\t\t}, { once: true, signal: getLockSignal(lock) });\n\t\t}\n\n\t\tswitch(mode) {\n\t\t\tcase 'exclusive': {\n\t\t\t\tif (ifAvailable && (held.length !== 0 || pending.length !== 0)) {\n\t\t\t\t\tconst controller = locks.get(lock).controller;\n\t\t\t\t\tlocks.delete(lock);\n\t\t\t\t\treturn await callFunction(callback, null).then(result => {\n\t\t\t\t\t\trequestIdleCallback(() => controller.abort());\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait whenNotBlocked(lock);\n\t\t\t\t\treturn await executeLock(lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcase 'shared': {\n\t\t\t\tif (! ifAvailable) {\n\t\t\t\t\tawait whenNotBlocked(lock);\n\t\t\t\t\treturn await executeLock(lock);\n\t\t\t\t} else if ([...held, ...pending].some(lock => lock.mode === 'exclusive')) {\n\t\t\t\t\tconst controller = locks.get(lock).controller;\n\t\t\t\t\tlocks.delete(lock);\n\t\t\t\t\treturn await callFunction(callback, null).then(result => {\n\t\t\t\t\t\trequestIdleCallback(() => controller.abort());\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tawait whenNotBlocked(lock);\n\t\t\t\t\treturn await executeLock(lock);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdefault:\n\t\t\t\tthrow new TypeError(`LockManager.request: '${mode}' (value of 'mode' member of LockOptions) is not a valid value for enumeration LockMode.`);\n\t\t}\n\t}\n\n\t/**\n\t * @see https://developer.mozilla.org/en-US/docs/Web/API/LockManager/query\n\t * @return {Promise} { held: [], pending: [] }\n\t */\n\tstatic async query() {\n\t\treturn {\n\t\t\theld: getHeldLocks().map(({ name, mode }) => ({ name, mode, clientId: null })),\n\t\t\tpending: getPendingLocks().map(({ name, mode }) => ({ name, mode, clientId: null })),\n\t\t};\n\t}\n}\n\nexport async function request(...args) {\n\tif (await actuallySupported) {\n\t\treturn navigator.locks.request(...args);\n\t} else {\n\t\treturn LockManager.request(...args);\n\t}\n}\n\nexport async function query() {\n\tif (await actuallySupported) {\n\t\treturn navigator.locks.query();\n\t} else {\n\t\treturn LockManager.query();\n\t}\n}\n\nexport async function polyfill() {\n\tif (! nativeSupport) {\n\t\tglobalThis.Lock = Lock;\n\t\tglobalThis.LockManager = LockManager;\n\t\tnavigator.locks = LockManager;\n\t} else if (! await actuallySupported) {\n\t\tnavigator.locks.request = (...args) => LockManager.request(...args);\n\t\tnavigator.locks.query = () => LockManager.query();\n\t}\n}\n","/**\n * @copyright 2023 Chris Zuber <admin@kernvalley.us>\n */\nexport const TEXT = 'text/plain';\nexport const HTML = 'text/html';\nexport const CSS = 'text/css';\nexport const JS = 'application/javascript';\nexport const JSON = 'application/json';\nexport const XML = 'application/xml';\nexport const JSON_LD = 'application/ld+json';\nexport const JPEG = 'image/jpeg';\nexport const PNG = 'image/png';\nexport const GIF = 'image/gif';\nexport const WEBP = 'image/webp';\nexport const SVG = 'image/svg+xml';\nexport const FORM_URL_ENCODED = 'application/x-www-form-urlencoded';\nexport const FORM_MULTIPART = 'multipart/form-data';\n","/**\n * @copyright 2023 Chris Zuber <admin@kernvalley.us>\n */\nimport { clamp, between } from './math.js';\nimport { isObject, isNullish } from './utility.js';\nimport { toHexColor, parseHexColor } from './color-utils.js';\nimport { setAttr, isScriptURL, isTrustedType } from './trust.js';\nimport { COLOR } from './patterns.js';\n\nexport function getAttrs(el) {\n\tif (typeof el === 'string') {\n\t\treturn getAttrs(document.querySelector(el));\n\t} else if (el instanceof Element) {\n\t\treturn Object.fromEntries([...el.attributes].map(({ name, value }) => [name, value]));\n\t} else {\n\t\tthrow new TypeError(`Expected an element or selector but got a ${typeof el}`);\n\t}\n}\n\nexport function aria(el, props = {}) {\n\tif (! (el instanceof Element)) {\n\t\tthrow new TypeError('`el` must be an Element');\n\t} else {\n\t\tObject.entries(props).forEach(([prop, val]) => {\n\t\t\tif (prop !== 'role') {\n\t\t\t\tprop = `aria-${prop.toLowerCase()}`;\n\t\t\t}\n\n\t\t\tif (isNullish(val)) {\n\t\t\t\tel.removeAttribute(prop);\n\t\t\t} else {\n\t\t\t\tel.setAttribute(prop, val);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function data(el, props = {}) {\n\tif (! (el instanceof Element)) {\n\t\tthrow new TypeError('el must be an Element');\n\t} if (! isObject(props)) {\n\t\tthrow new TypeError('props must be an object');\n\t} else {\n\t\tObject.entries(props).forEach(([p, v]) => {\n\t\t\tswitch (typeof v) {\n\t\t\t\tcase 'string':\n\t\t\t\tcase 'number':\n\t\t\t\t\tel.dataset[p] = v.toString();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'boolean':\n\t\t\t\t\tif (v) {\n\t\t\t\t\t\tel.dataset[p] = '';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelete el.dataset[p];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'undefined':\n\t\t\t\t\tdelete el.dataset[p];\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'object':\n\t\t\t\t\tif (Object.is(v, null)) {\n\t\t\t\t\t\tdelete el.dataset[p];\n\t\t\t\t\t} else if (v instanceof Date) {\n\t\t\t\t\t\tel.dataset[p] = v.toISOString();\n\t\t\t\t\t} else if (v instanceof URL) {\n\t\t\t\t\t\tel.dataset[p] = v.href;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tel.dataset[p] = JSON.stringify(v);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(`Unable to handle type: ${typeof v}`);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function css(el, props = {}, { priority } = {}) {\n\tif (! (el instanceof Element)) {\n\t\tthrow new TypeError('el must be an Element');\n\t} if (! isObject(props)) {\n\t\tthrow new TypeError('props must be an object');\n\t} else {\n\t\tObject.entries(props).forEach(([p, v]) => {\n\t\t\tif (typeof v === 'string' || typeof v === 'number') {\n\t\t\t\tel.style.setProperty(p, v, priority);\n\t\t\t} else if (v instanceof URL) {\n\t\t\t\tel.type.setProperty(p, v.href, priority);\n\t\t\t} else if (typeof v === 'object' && ! Object.is(v, null) && v.toString instanceof Function) {\n\t\t\t\tel.style.setProperty(p, v.toString(), priority);\n\t\t\t} else {\n\t\t\t\tel.style.removeProperty(p);\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function attr(el, props = {}, {\n\tnamespace: elementNs = null,\n\tpolicy,\n} = {}) {\n\tif (! (el instanceof Element)) {\n\t\tthrow new TypeError('el must be an Element');\n\t} if (! isObject(props)) {\n\t\tthrow new TypeError('props must be an object');\n\t} else {\n\t\tObject.entries(props).forEach(([p, v]) => {\n\t\t\tif (typeof v === 'string' || typeof v === 'number') {\n\t\t\t\tsetAttr(el, p, v, { policy, elementNs });\n\t\t\t} else if ('trustedTypes' in globalThis && isTrustedType(v)) {\n\t\t\t\tif (v.toString().length === 0) {\n\t\t\t\t\tel.removeAttribute(p);\n\t\t\t\t} else {\n\t\t\t\t\tsetAttr(el, p, v, { policy, elementNs });\n\t\t\t\t}\n\t\t\t} else if (typeof v === 'boolean') {\n\t\t\t\tif (typeof namespace === 'string') {\n\t\t\t\t\tv ? el.setAttributeNS(elementNs, p, '') : el.removeAttributeNS(elementNs, p);\n\t\t\t\t} else {\n\t\t\t\t\tel.toggleAttribute(p, v);\n\t\t\t\t}\n\t\t\t} else if (v instanceof Date) {\n\t\t\t\tsetAttr(el, p, v.toISOString(), { policy, elementNs });\n\t\t\t} else if (v instanceof URL) {\n\t\t\t\tsetAttr(el, p, v.href, { policy, elementNs });\n\t\t\t} else if (typeof v === 'undefined' || v === null) {\n\t\t\t\tif (typeof namespace === 'string') {\n\t\t\t\t\tel.removeAttributeNS(elementNs, p);\n\t\t\t\t} else {\n\t\t\t\t\tel.removeAttribute(p);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsetAttr(el, p, JSON.stringify(v), { policy, elementNs });\n\t\t\t}\n\t\t});\n\t}\n}\n\nexport function getBool(el, attr) {\n\treturn el.hasAttribute(attr);\n}\n\nexport function setBool(el, attr, val) {\n\tel.toggleAttribute(attr, val);\n}\n\nexport function getInt(el, attr, {\n\tfallback = NaN,\n\tmin = Number.MIN_SAFE_INTEGER,\n\tmax = Number.MAX_SAFE_INTEGER,\n} = {}) {\n\tif (el.hasAttribute(attr)) {\n\t\tconst val = clamp(min, parseInt(el.getAttribute(attr)), max);\n\t\treturn Number.isNaN(val) ? fallback : val;\n\t} else {\n\t\treturn fallback;\n\t}\n}\n\nexport function setInt(el, attr, val, {\n\tmin = Number.MIN_SAFE_INTEGER,\n\tmax = Number.MAX_SAFE_INTEGER,\n\tpolicy,\n} = {}) {\n\tif (val instanceof Date) {\n\t\tsetAttr(el, attr, val.getTime(), { min, max, policy});\n\t} else if (Number.isInteger(val)) {\n\t\tsetAttr(el, attr, clamp(min, val, max), { policy });\n\t} else if (typeof val === 'string') {\n\t\tsetInt(el, attr, parseInt(val), { min, max });\n\t} else {\n\t\tel.removeAttribute(attr);\n\t}\n}\n\nexport function getFloat(el, attr, {\n\tfallback = NaN,\n\tmin = Number.MIN_SAFE_INTEGER,\n\tmax = Number.MAX_SAFE_INTEGER,\n} = {}) {\n\tif (el.hasAttribute(attr)) {\n\t\tconst val = clamp(min, parseFloat(el.getAttribute(attr)), max);\n\t\treturn Number.isNaN(val) ? fallback : val;\n\t} else {\n\t\treturn fallback;\n\t}\n}\n\nexport function setFloat(el, attr, val, {\n\tmin = Number.MIN_SAFE_INTEGER,\n\tmax = Number.MAX_SAFE_INTEGER,\n\tpolicy,\n} = {}) {\n\tif (typeof val === 'number' && ! Number.isNaN(val)) {\n\t\tsetAttr(el, attr, clamp(min, val, max), { policy });\n\t} else if (typeof val === 'string') {\n\t\tsetFloat(el, attr, parseFloat(val), { min, max });\n\t} else {\n\t\tel.removeAttribute(attr);\n\t}\n}\n\nexport function getString(el, attr, { fallback = null } = {}) {\n\tif (el.hasAttribute(attr)) {\n\t\treturn el.getAttribute(attr) || fallback;\n\t} else {\n\t\treturn fallback;\n\t}\n}\n\nexport function setString(el, attr, val, {\n\tminLength = 1,\n\tmaxLength = Infinity,\n\tpattern   = null,\n\tfallback,\n\tpolicy,\n} = {}) {\n\tif (\n\t\ttypeof val === 'string'\n\t\t&& between(minLength, val.length, maxLength)\n\t\t&& (! (pattern instanceof RegExp) || pattern.test(val))\n\t) {\n\t\tsetAttr(el, attr, val, { policy });\n\t} else if(isTrustedType(val)) {\n\t\tconst str = val.toString();\n\n\t\tif (\n\t\t\tbetween(minLength, str.length, maxLength)\n\t\t\t&& (! (pattern instanceof RegExp) || pattern.test(str))\n\t\t) {\n\t\t\tsetAttr(el, attr, val, { policy });\n\t\t} else {\n\t\t\tel.removeAttribute(attr);\n\t\t}\n\t} else if (typeof fallback === 'string' || isTrustedType(fallback)) {\n\t\tsetString(el, attr, fallback, { pattern, policy, minLength, maxLength });\n\t} else {\n\t\tel.removeAttribute(attr);\n\t}\n}\n\nexport function getURL(el, attr, { base = document.baseURI } = {}) {\n\tif (el.hasAttribute(attr)) {\n\t\treturn new URL(el.getAttribute(attr), base);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport function setURL(el, attr, val, {\n\tbase = document.baseURI,\n\trequirePath = false,\n\tpolicy,\n} = {}) {\n\tif ((val instanceof URL) && (! requirePath || val.pathname.length > 1)) {\n\t\tsetAttr(el, attr, val.href, { policy });\n\t} else if (typeof val === 'string' && val.length !== 0) {\n\t\tsetURL(el, attr, new URL(val, base), { requirePath });\n\t} else if (isScriptURL(val)) {\n\t\tconst url = new URL(val.toString(), document.baseURI);\n\n\t\tif (! requirePath || url.pathname.length > 1) {\n\t\t\tsetAttr(el, attr, val, { policy });\n\t\t} else {\n\t\t\tel.removeAttribute(attr);\n\t\t}\n\t} else {\n\t\tel.removeAttribute(attr);\n\t}\n}\n\nexport function getEnum(el, attr, {\n\tallowed  = [],\n\tfallback = undefined,\n}) {\n\tif (! Array.isArray(allowed) || allowed.length === 0) {\n\t\tthrow new TypeError('`allowed` must be a non-empty array.');\n\t} else if (el.hasAttribute(attr)) {\n\t\tconst val = el.getAttribute(attr);\n\t\treturn allowed.includes(val) ? val : fallback;\n\t} else {\n\t\treturn fallback;\n\t}\n}\n\nexport function setEnum(el, attr, val, {\n\tallowed = [],\n\tfallback = undefined,\n}) {\n\tif (! Array.isArray(allowed) || allowed.length === 0) {\n\t\tthrow new TypeError('`allowed` must be a non-empty array.');\n\t} else if (allowed.includes(val)) {\n\t\tsetAttr(el, attr, val);\n\t} else if (! isNullish(fallback)) {\n\t\tsetAttr(el, attr, fallback);\n\t} else {\n\t\tel.removeAttribute(attr);\n\t}\n}\n\nexport function getColor(el, attr, { fallback } = {}) {\n\tconst val = getString(el, attr);\n\treturn typeof val === 'string' && COLOR.test(val) ? val : fallback;\n}\n\nexport function setColor(el, attr, val, { fallback } = {}) {\n\tsetString(el, attr, val, { fallback, minLength: 3, maxLength: 9, pattern: COLOR });\n}\n\nexport function getRGB(el, attr, { fallback = '#000000' } = {}) {\n\tconst { red = 0, green = 0, blue = 0 } = parseHexColor(getColor(el, attr, { fallback }));\n\treturn { red, green, blue };\n}\n\nexport function setRGB(el, attr, { red = 0, green = 0, blue = 0 } = {}) {\n\tsetColor(el, attr, toHexColor({ red, green, blue }));\n}\n\nexport function getRGBA(el, attr, { fallback = '#000000' } = {}) {\n\tconst { red = 0, green = 0, blue = 0, alpha = 1 } = parseHexColor(getColor(el, attr, { fallback }));\n\treturn { red, green, blue, alpha };\n}\n\nexport function setRGBA(el, attr, { red = 0, green = 0, blue = 0, alpha = 1 } = {}) {\n\tsetColor(el, attr, toHexColor({ red, green, blue, alpha }));\n}\n\nexport { setAttr };\n","/**\n * @copyright 2021-2023 Chris Zuber <admin@kernvalley.us>\n */\nimport { signalAborted } from './abort.js';\nimport { addListener, listen, loaded as whenLoaded } from './events.js';\nimport { getDeferred, isAsync } from './promises.js';\nimport { isHTML, isTrustPolicy } from './trust.js';\nimport { HTML } from './types.js';\nimport { errorToEvent, callOnce } from './utility.js';\nimport { data as setData, css as setCss, attr as setAttr, aria as setAria } from './attrs.js';\nimport { createElement } from './elements.js';\n\nexport const readyStates = ['loading', 'interactive', 'complete'];\n\nexport const readyStateIndex = (state = document.readyState) => readyStates.indexOf(state);\n\nexport const reachedState = state => ! readyStateIndex(document.readyState) > readyStateIndex(state);\n\nexport function query(what, base = document) {\n\tif (Array.isArray(what)) {\n\t\treturn what;\n\t} else if (what instanceof EventTarget) {\n\t\treturn [what];\n\t} else if (typeof what === 'string') {\n\t\tconst matches = Array.from(base.querySelectorAll(what));\n\n\t\tif (base.matches instanceof Function && base.matches(what)) {\n\t\t\tmatches.push(base);\n\t\t}\n\t\treturn matches;\n\t} else if (typeof what === 'object' && what[Symbol.iterator] instanceof Function) {\n\t\treturn Array.from(what);\n\t} else {\n\t\tthrow new TypeError('Invalid \"what\" given to query()');\n\t}\n}\n\nexport function nth(what, n, { base } = {}) {\n\treturn query(what, base).at(n);\n}\n\nexport function first(what, base) {\n\treturn nth(what, 0, { base });\n}\n\nexport function last(what, base) {\n\treturn nth(what, -1, { base });\n}\n\nexport function each(what, callback, { base } = {}) {\n\tconst items = query(what, base);\n\titems.forEach(callback);\n\treturn items;\n}\n\nexport function map(what, callback, { base } = {}) {\n\treturn query(what, base).map(callback);\n}\n\nexport function some(what, callback, { base } = {}) {\n\treturn query(what, base).some(callback);\n}\n\nexport function every(what, callback, { base } = {}) {\n\treturn query(what, base).every(callback);\n}\n\nexport function find(what, callback, { base } = {}) {\n\treturn query(what, base).find(callback);\n}\n\nexport function filter(what, callback, { base } = {}) {\n\treturn query(what, base).filter(callback);\n}\n\nexport function groupByToMap(what, callback, { base } = {}) {\n\treturn query(what, base).groupByToMap(callback);\n}\n\nexport function groupBy(what, callback, { base } = {}) {\n\treturn query(what, base).groupBy(callback);\n}\n\n/**\n * @deprecated\n */\nexport function create(tag, { attrs = {}, ...rest } = {}) {\n\tconsole.warn('`create()` is deprecated. Please use `createElement()` instead.');\n\treturn createElement(tag, { ...attrs, ...rest });\n}\n\nexport function append(parent, ...nodes) {\n\tparent.append(...nodes);\n}\n\nexport function remove(what, { base } = {}) {\n\treturn each(what, item => item.remove(), { base });\n}\n\nexport function meta({ name, itemprop, property, charset, content }) {\n\tconst meta = document.createElement('meta');\n\n\tif (typeof name === 'string') {\n\t\tmeta.name = name;\n\t\tmeta.content = content;\n\t} else if (typeof itemprop === 'string') {\n\t\tmeta.setAttribute('itemprop', itemprop);\n\t\tmeta.content = content;\n\t} else if (typeof property === 'string') {\n\t\tmeta.setAttribute('property', property);\n\t\tmeta.content = content;\n\t} else if (typeof charset === 'string') {\n\t\tmeta.setAttribute('charset', charset);\n\t} else {\n\t\tthrow new Error('Meta must have either name, itemprop, property, or charset given');\n\t}\n\n\treturn meta;\n}\n\nexport function css(what, props = {}, { base, priority } = {}) {\n\treturn each(what, item => setCss(item, props, { priority }), { base });\n}\n\nexport function aria(what, props ={}, { base } = {}) {\n\teach(what, item => setAria(item, props), { base });\n}\n\nexport function data(what, props = {}, { base } = {}) {\n\treturn each(what, item => setData(item, props), { base });\n}\n\nexport function attr(what, props = {}, { base, namespace = null, policy } = {}) {\n\treturn each(what, item => setAttr(item, props, { namespace, policy }), { base });\n}\n\nexport function toggleAttr(what, attrs, { base, force, signal } = {}) {\n\tif (! Array.isArray(attrs)) {\n\t\tattrs = [attrs];\n\t}\n\tconst items = query(what, base);\n\n\tif (! (signal instanceof AbortSignal)) {\n\t\titems.forEach(item => attrs.forEach(attr => item.toggleAttribute(attr, force)));\n\t} else if (signal.aborted) {\n\t\titems.forEach(item => attrs.forEach(attr => item.removeAttribute(attr)));\n\t} else {\n\t\tif (typeof force !== 'boolean') {\n\t\t\tforce = true;\n\t\t}\n\n\t\titems.forEach(item => attrs.forEach(attr => item.toggleAttribute(attr, force)));\n\n\t\tsignal.addEventListener('abort', () => {\n\t\t\titems.forEach(item => attrs.forEach(attr => item.toggleAttribute(attr, !force)));\n\t\t}, { once: true });\n\t}\n\treturn items;\n}\n\nexport function disable(what, { base, value = true } = {}) {\n\treturn each(what, el => el.disabled = value, { base });\n}\n\nexport function enable(what, { base, value = false } = {}) {\n\treturn disable(what, { base, value });\n}\n\nexport function hide(what, { base, value = true } = {}) {\n\treturn each(what, el => el.hidden = value, { base });\n}\n\nexport function unhide(what, { base, value = false } = {}) {\n\treturn hide(what, { base, value });\n}\n\nexport function value(what, value, { base } = {}) {\n\tif (value == null) {\n\t\treturn each(what, el => el.removeAttribute('value'), { base });\n\t} else {\n\t\treturn each(what, el => el.value = value, { base });\n\t}\n}\n\nexport function addClass(what, ...args) {\n\treturn each(what, el => el.classList.add(...args));\n}\n\nexport function removeClass(what, ...args) {\n\treturn each(what, el => el.classList.remove(...args));\n}\n\nexport function toggleClass(what, classes = {}, { base, force } = {}) {\n\treturn each(what, item => {\n\t\tif (typeof classes === 'string') {\n\t\t\treturn item.classList.toggle(classes, force);\n\t\t} else if (Array.isArray(classes)) {\n\t\t\tclasses.forEach(cn => item.classList.toggle(cn, force));\n\t\t} else {\n\t\t\tObject.entries(classes).forEach(([cl, cond]) => {\n\t\t\t\tif (cond instanceof Function) {\n\t\t\t\t\titem.classList.toggle(cl, cond.apply(what, [cl]));\n\t\t\t\t} else if (cond instanceof AbortSignal) {\n\t\t\t\t\tif (cond.aborted) {\n\t\t\t\t\t\titem.classList.remove(cl);\n\t\t\t\t\t} else {\n\t\t\t\t\t\titem.classList.add(cl, true);\n\t\t\t\t\t\tcond.addEventListener('abort', () => {\n\t\t\t\t\t\t\titem.classList.remove(cl);\n\t\t\t\t\t\t}, { once: true });\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\titem.classList.toggle(cl, cond);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}, { base });\n}\n\nexport function replaceClass(what, classes = {}, { base } = {}) {\n\tconst entries = Object.entries(classes);\n\n\treturn each(what, item => {\n\t\tentries.forEach(([from, to]) => item.classList.replace(from, to));\n\t}, { base });\n}\n\nexport function text(what, text, { base } = {}) {\n\treturn each(what, el => el.textContent = text, { base });\n}\n\nexport function html(what, text, {\n\tbase,\n\tsanitizer,\n\tpolicy = 'trustedTypes' in globalThis ? globalThis.trustedTypes.defaultPolicy : undefined,\n} = {}) {\n\tif (typeof sanitizer !== 'undefined' && Element.prototype.setHTML instanceof Function) {\n\t\treturn each(what, el => el.setHTML(text, { sanitizer }), { base });\n\t} else if (isHTML(text)) {\n\t\treturn each(what, el => el.innerHTML = text, { base });\n\t} else if (typeof policy !== 'undefined' && policy.createHTML instanceof Function) {\n\t\ttext = policy.createHTML(text);\n\t\treturn each(what, el => el.innerHTML = text, { base });\n\t} else {\n\t\treturn each(what, el => el.innerHTML = text, { base });\n\t}\n}\n\nexport function on(what, when, ...args) {\n\t// @TODO: Figure out a way of adding `base` to arguments\n\tconst items = query(what);\n\n\tif (typeof when === 'string') {\n\t\taddListener(items, [when], ...args);\n\t} else if (Array.isArray(when)) {\n\t\taddListener(items, when, ...args);\n\t} else {\n\t\tObject.entries(when).forEach(([ev, cb]) => addListener(items, [ev], cb, ...args));\n\t}\n\n\treturn items;\n}\n\nexport function prevent(what, event = 'submit', { signal, capture } = {}) {\n\treturn on(what, event, ev => ev.preventDefault(), { signal, capture });\n}\n\nexport function off(what, when, ...args) {\n\treturn each(what, item => {\n\t\tif (typeof when === 'string') {\n\t\t\titem.removeEventListener(when, ...args);\n\t\t} else if (Array.isArray(when)) {\n\t\t\twhen.forEach(e =>  item.removeEventListener(e, ...args));\n\t\t} else {\n\t\t\tObject.entries(when).forEach(([ev, cb]) => item.removeEventListener(ev, cb, ...args));\n\t\t}\n\t});\n}\n\nexport async function when(what, events, { capture, passive, signal, base } = {}) {\n\tconst controller = new AbortController();\n\tconst { promise, resolve, reject } = getDeferred();\n\n\tif (signal instanceof AbortSignal) {\n\t\tif (signal.aborted) {\n\t\t\tcontroller.abort(signal.reason);\n\t\t} else {\n\t\t\taddEventListener([signal], ['abort'], () => {\n\t\t\t\tcontroller.abort(signal.reason);\n\t\t\t\treject(signal.reason);\n\t\t\t}, { once: true, signal: controller.signal });\n\t\t}\n\t}\n\n\tif (controller.signal.aborted) {\n\t\treject(controller.signal.reason);\n\t} else {\n\t\ton(query(what, base), events, event => {\n\t\t\tresolve(event);\n\t\t\tcontroller.abort();\n\t\t}, { capture, passive, signal: controller.signal });\n\t}\n\n\treturn promise;\n}\n\nexport const ready = callOnce(async function ready({ signal } = {}) {\n\tconst { promise, resolve, reject } = getDeferred();\n\n\tif (signal instanceof AbortSignal && signal.aborted) {\n\t\treject(signal.reason || new DOMException('Operation aborted.'));\n\t} else if (readyStateIndex() === 0) {\n\t\tlisten(document, 'DOMContentLoaded', resolve, { signal, once: true, capture: true });\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignal.addEventListener('abort',\n\t\t\t\t({ target }) => reject(target.reason || new DOMException('Operation aborted.')),\n\t\t\t\t{ once: true }\n\t\t\t);\n\t\t}\n\t} else {\n\t\tresolve();\n\t}\n\n\treturn promise;\n});\n\nexport async function whenReadyState(state, { signal } = {}) {\n\tconst { resolve, reject, promise } = getDeferred();\n\tconst stateIndex = readyStateIndex(state);\n\n\tif (signal instanceof AbortSignal && signal.aborted) {\n\t\treject(signal.reason || new DOMException('Operation aborted.'));\n\t} else if (stateIndex < 0) {\n\t\treject(new DOMException(`Invalid state: ${state}`));\n\t} else if (stateIndex > readyStateIndex()) {\n\t\tconst controller = new AbortController();\n\t\tlet settled = false;\n\n\t\tcontroller.signal.addEventListener('abort', ({ target }) => {\n\t\t\tif (! settled) {\n\t\t\t\treject(target.reason || new DOMException('Operation aborted.'));\n\t\t\t\tsettled = true;\n\t\t\t}\n\t\t}, { once: true });\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignal.addEventListener('abort', ({ target }) => {\n\t\t\t\tcontroller.abort(target.reason);\n\t\t\t}, { once: true, signal: controller.signal });\n\t\t}\n\n\t\tdocument.addEventListener('readystatechange', () => {\n\t\t\tif (document.readyState === state) {\n\t\t\t\tresolve();\n\t\t\t\tsettled = true;\n\t\t\t\tcontroller.abort();\n\t\t\t}\n\t\t}, { signal: controller.signal });\n\t} else {\n\t\tresolve();\n\t}\n\n\treturn promise;\n}\n\nexport const interactive =  callOnce(async function interactive({ signal } = {}) {\n\tawait whenReadyState('interactive', { signal });\n});\n\nexport const complete = callOnce(async function complete({ signal } = {}) {\n\tawait whenReadyState('complete', { signal });\n});\n\nexport const loaded =  callOnce(async function loaded({ signal } = {}) {\n\tconst { promise, resolve, reject } = getDeferred();\n\n\tif (signal instanceof AbortSignal && signal.aborted) {\n\t\treject(signal.reason || new DOMException('Operation aborted.'));\n\t} else if (readyStateIndex() < 2) {\n\t\tlisten(globalThis, 'load', resolve, { signal, once: true, capture: true });\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignal.addEventListener('abort',\n\t\t\t\t({ target }) => reject(target.reason || new DOMException('Operation aborted.')),\n\t\t\t\t{ once: true }\n\t\t\t);\n\t\t}\n\t} else {\n\t\tresolve();\n\t}\n\n\treturn promise;\n});\n\nexport const unloaded = callOnce(async function unloaded({ signal } = {}) {\n\tconst { promise, resolve } = getDeferred();\n\tlisten(globalThis, 'unload', resolve, { signal, once: true, capture: true });\n\treturn promise;\n});\n\nexport const beforeUnload = callOnce(async function beforeUnload({ signal } = {}) {\n\tconst { promise, resolve } = getDeferred({ signal });\n\tlisten(globalThis, 'beforeunload', resolve, { signal, once: true, capture: true });\n\treturn promise;\n});\n\nexport const beforeInstallPrompt = callOnce(async function({ signal } = {}) {\n\tconst { promise, resolve, reject } = getDeferred();\n\n\tif (signal instanceof AbortSignal && signal.aborted) {\n\t\treject(signal.reason);\n\t} else if ('onbeforeinstallprompt' in globalThis) {\n\t\tlisten(globalThis, 'beforeinstallprompt', resolve, { once: true, capture: true, signal });\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tlisten(signal, 'abort', ({ reason }) => reject(reason), { once: true });\n\t\t}\n\t}\n\n\treturn await promise;\n});\n\nexport async function whenPageVisible({ signal } = {}) {\n\tconst { promise, resolve } = getDeferred({ signal });\n\n\tif (document.visibilityState === 'visible') {\n\t\tresolve();\n\t} else {\n\t\tlisten(document, 'visibilitychange', () => resolve(), { once: true, signal });\n\t}\n\n\treturn promise;\n}\n\nexport async function whenPageHidden({ signal } = {}) {\n\tconst { promise, resolve } = getDeferred({ signal });\n\n\tif (document.visibilityState === 'hidden') {\n\t\tresolve();\n\t} else {\n\t\tlisten(document, 'visibilitychange', () => resolve(), { once: true, signal });\n\t}\n\n\treturn promise;\n}\n\n/**\n * @deprecated [will be removed in v3.0.0]\n */\nexport function parseHTML(text, {\n\ttype = HTML,\n\tasFrag = true,\n\thead = true,\n\tsanitizer,\n\tpolicy,\n} = {}) {\n\tconsole.warn('`parseHTML` is deprecated. Please use `parse` instead');\n\treturn parse(text, { type, asFrag, head, sanitizer, policy });\n}\n\nexport function parse(text, {\n\ttype = HTML,\n\tasFrag = true,\n\tsanitizer,\n\tpolicy = 'trustedTypes' in globalThis ? globalThis.trustedTypes.defaultPolicy : undefined,\n} = {}) {\n\tconst parser = new DOMParser();\n\n\tif (asFrag) {\n\t\treturn parseAsFragment(text, { sanitizer, policy });\n\t} else if (isTrustPolicy(policy) && ! isHTML(text)) {\n\t\treturn parser.parseFromString(policy.createHTML(text), type);\n\t} else {\n\t\treturn parser.parseFromString(text, type);\n\t}\n}\n\nexport function documentToFragment(doc, { sanitizer } = {}) {\n\tconst clone = doc.cloneNode(true);\n\tconst frag = document.createDocumentFragment();\n\tfrag.append(...clone.head.childNodes, ...clone.body.childNodes);\n\n\treturn typeof sanitizer !== 'undefined' && sanitizer.sanitize instanceof Function\n\t\t? sanitizer.sanitize(frag) : frag;\n}\n\nexport function parseAsFragment(text, {\n\tsanitizer,\n\tpolicy = 'trustedTypes' in globalThis ? globalThis.trustedTypes.defaultPolicy : undefined,\n} = {}) {\n\tconst tmp = document.createElement('template');\n\n\tif (isTrustPolicy(policy) && ! isHTML(text)) {\n\t\ttmp.innerHTML = policy.createHTML(text);\n\t} else {\n\t\ttmp.innerHTML = text;\n\t}\n\n\treturn typeof sanitizer !== 'undefined' && sanitizer.sanitize instanceof Function\n\t\t? sanitizer.sanitize(tmp.content)\n\t\t: tmp.content;\n}\n\nexport function animate(what, keyframes, opts = { duration: 400 }) {\n\tif (opts.signal instanceof AbortSignal && opts.signal.aborted) {\n\t\tthrow opts.signal.reason;\n\t} else if (! (Element.prototype.animate instanceof Function)) {\n\t\tthrow new DOMException('Animations not supported');\n\t} else {\n\t\tif (Number.isInteger(opts)) {\n\t\t\topts = { duration: opts };\n\t\t}\n\n\t\tconst animations = query(what).map(item => item.animate(keyframes, opts));\n\n\t\tif (opts.signal instanceof AbortSignal) {\n\t\t\topts.signal.addEventListener('abort', () => animations.forEach(anim => anim.cancel()), { once: true });\n\t\t}\n\n\t\treturn animations;\n\t}\n}\n\nexport function intersect(what, callback, { root, rootMargin, signal, threshold } = {}) {\n\tif (signal instanceof AbortSignal && signal.aborted) {\n\t\tthrow signal.reason;\n\t} else if (! ('IntersectionObserver' in globalThis)) {\n\t\tthrow new DOMException('IntersectionObserver not supported');\n\t} else {\n\t\tconst observer = new IntersectionObserver((entries, observer) => {\n\t\t\tentries.forEach((entry, index) => callback.apply(null, [entry, observer, index]));\n\t\t}, { root, rootMargin, threshold });\n\n\t\teach(what, item => observer.observe(item));\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignalAborted(signal).finally(() => observer.disconnect());\n\t\t}\n\n\t\treturn observer;\n\t}\n}\n\nexport function mutate(what, callback, options = {}) {\n\tif ('MutationObserver' in globalThis) {\n\t\tconst observer = new MutationObserver((records, observer) => {\n\t\t\trecords.forEach((record, index) => callback.apply(null, [record, observer, index]));\n\t\t});\n\n\t\teach(what, item => observer.observe(item, options));\n\n\t\tif (options.signal instanceof AbortSignal) {\n\t\t\tsignalAborted(options.signal).finally(() => observer.disconnect());\n\t\t}\n\n\t\treturn observer;\n\t} else {\n\t\tthrow new Error('MutationObserver not supported');\n\t}\n}\n\n/**\n * @Deprecated\n */\nexport async function scriptLoaded(script) {\n\tconsole.warn('`scriptLoaded()` is deprecated. Use `loaded()` from `events.js` instead.');\n\t/*\n\t * `loaded()` aliased as `whenLoaded()`\n\t */\n\treturn await whenLoaded(script);\n}\n\n/**\n * @Deprecated\n */\nexport async function linkLoaded(link) {\n\tconsole.warn('`linkLoaded()` is deprecated. Use `loaded()` from `events.js` instead.');\n\t/*\n\t * `loaded()` aliased as `whenLoaded()`\n\t */\n\treturn await whenLoaded(link);\n}\n\nexport function stripComments(node) {\n\tif (! (node instanceof Node)) {\n\t\tthrow new TypeError('Cannot strip comments from non-node');\n\t} else {\n\t\tswitch(node.nodeType) {\n\t\t\tcase Node.ELEMENT_NODE:\n\t\t\tcase Node.DOCUMENT_NODE:\n\t\t\tcase Node.DOCUMENT_FRAGMENT_NODE:\n\t\t\t\tif (node.hasChildNodes()) {\n\t\t\t\t\t[...node.childNodes].forEach(stripComments);\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase Node.COMMENT_NODE:\n\t\t\t\tnode.remove();\n\t\t\t\tbreak;\n\t\t}\n\t}\n}\n\nexport function supportsElement(...tags) {\n\treturn ! tags.some(tag => document.createElement(tag) instanceof HTMLUnknownElement);\n}\n\nexport function createTable(data, { caption, header, footer } = {}) {\n\tconst table = document.createElement('table');\n\tif (Array.isArray(data)) {\n\t\tdata.forEach(row => {\n\t\t\tif (Array.isArray(row)) {\n\t\t\t\tconst tr = table.insertRow();\n\t\t\t\trow.forEach(cell => tr.insertCell().textContent = cell);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (Array.isArray(header)) {\n\t\tconst tHead = table.createTHead();\n\t\tconst row = tHead.insertRow();\n\t\trow.append(...header.map(cell => {\n\t\t\tconst th = document.createElement('th');\n\t\t\tth.scope = 'col';\n\t\t\tth.textContent = cell;\n\t\t\treturn th;\n\t\t}));\n\t}\n\n\tif (Array.isArray(footer)) {\n\t\tconst tFoot = table.createTFoot();\n\t\tconst row = tFoot.insertRow();\n\t\trow.append(...footer.map(cell => {\n\t\t\tconst th = document.createElement('th');\n\t\t\tth.textContent = cell;\n\t\t\treturn th;\n\t\t}));\n\t}\n\n\tif (typeof caption === 'string') {\n\t\ttable.createCaption().textContent = caption;\n\t}\n\n\treturn table;\n}\n\nexport { addListener, isAsync, errorToEvent };\n","const symbols = { resp: Symbol('resp') };\n\nexport class HTTPException extends Error {\n\tconstructor(resp = Response.error(), { message, cause } = {}) {\n\t\tsuper(\n\t\t\ttypeof message === 'string' ? message :`<${resp.url}> [${resp.status} ${resp.statusText}]`,\n\t\t\t{ cause }\n\t\t);\n\n\t\tObject.defineProperty(this, symbols.resp, {\n\t\t\tvalue: resp,\n\t\t\tconfigurable: false,\n\t\t\twritable: false,\n\t\t\tenumerable: false,\n\t\t});\n\t}\n\n\tasync json() {\n\t\treturn await this[symbols.resp].json();\n\t}\n\n\tasync text() {\n\t\treturn await this[symbols.resp].text();\n\t}\n\n\tget body() {\n\t\treturn this[symbols.resp].body;\n\t}\n\n\tget bodyUsed() {\n\t\treturn this[symbols.resp].bodyUsed;\n\t}\n\n\tget headers() {\n\t\treturn this[symbols.resp].headers;\n\t}\n\n\tget ok() {\n\t\treturn this[symbols.resp].ok;\n\t}\n\n\tget redirected() {\n\t\treturn this[symbols.resp].redirected;\n\t}\n\n\tget status() {\n\t\treturn this[symbols.resp].status;\n\t}\n\n\tget statusText() {\n\t\treturn this[symbols.resp].statusText;\n\t}\n\n\tget type() {\n\t\treturn this[symbols.resp].type;\n\t}\n\n\tget url() {\n\t\treturn this[symbols.resp].url;\n\t}\n\n\ttoJSON() {\n\t\tconst { status, statusText, ok, url, message, type, redirected } = this;\n\t\treturn { status, ok, statusText, url, message, type, redirected };\n\t}\n}\n","/**\n * @copyright 2021-2023 Chris Zuber <admin@kernvalley.us>\n */\nimport { parse } from './dom.js';\nimport { signalAborted } from './abort.js';\nimport { setURLParams, setUTMParams, isObject, isNullish, callOnce } from './utility.js';\nimport { isTrustPolicy } from './trust.js';\nimport { HTTPException } from './HTTPException.js';\nimport * as TYPES from './types.js';\n\nfunction filename(src) {\n\tif (typeof src === 'string') {\n\t\treturn new URL(src, location.origin).pathname.split('/').at(-1);\n\t} else {\n\t\treturn '';\n\t}\n}\n\nfunction getType({ headers }) {\n\tif (headers instanceof Headers && headers.has('Content-Type')) {\n\t\treturn headers.get('Content-Type').split(';')[0];\n\t} else {\n\t\treturn null;\n\t}\n}\n\nfunction handleResponse(resp, { cause, message } = {}) {\n\tif (! (resp instanceof Response)) {\n\t\tthrow new TypeError('Expected a Response object');\n\t} else if (! resp.ok) {\n\t\tthrow new HTTPException(resp, { cause, message });\n\t} else {\n\t\treturn resp;\n\t}\n}\n\nfunction handleError(err) {\n\tif (err instanceof HTTPException) {\n\t\tthrow err;\n\t} else if (err instanceof Error) {\n\t\tthrow new HTTPException(Response.error(), { cause: err, message: err.message });\n\t} else if (typeof err === 'string') {\n\t\tthrow new HTTPException(Response.error(), {\n\t\t\tcause: new DOMException('Unknown network error'),\n\t\t\tmessage: err,\n\t\t});\n\t} else {\n\t\tthrow new HTTPException(Response.error(), {\n\t\t\tcause: new DOMException('Unknown network error'),\n\t\t\tmessage: 'Unknown network error',\n\t\t});\n\t}\n}\n\nexport async function fetch(url, opts = {}) {\n\tif (opts.signal instanceof AbortSignal && opts.signal.aborted) {\n\t\tthrow new HTTPException(Response.error(), {\n\t\t\tcause: opts.signal.reason,\n\t\t\tmessage: opts.signal.reason instanceof Error ? opts.signal.reason.message : opts.signal.reason,\n\t\t});\n\t} else if (opts.signal instanceof AbortSignal && ! ('signal' in Request.prototype)) {\n\t\treturn await Promise.race([\n\t\t\tglobalThis.fetch(url, opts),\n\t\t\tsignalAborted(opts.signal),\n\t\t]).then(resp => handleResponse(resp, { message: opts.errorMessage }), handleError);\n\t} else {\n\t\treturn await globalThis.fetch(url, opts).then(resp => handleResponse(resp, { message: opts.errorMessage }), handleError);\n\t}\n}\n\nexport const getHTTPCSP = callOnce(async function getHTTPCSP() {\n\tconst { ok, headers } = await fetch(location.href, { method: 'HEAD' });\n\n\tif (ok && headers.has('Content-Security-Policy')) {\n\t\tconst directives = headers.get('Content-Security-Policy').trim().split(';').filter(str => str.length !== 0);\n\n\t\treturn Object.fromEntries(directives.map(directive => {\n\t\t\tconst [key, ...rest] = directive.trim().split(' ').filter(part => part.length !== 0);\n\t\t\treturn [key, rest];\n\t\t}));\n\t}\n});\n\nexport const getCSP = callOnce(async function getCSP() {\n\ttry {\n\t\tconst csp = await getHTTPCSP();\n\n\t\tif (typeof csp === 'object' && ! Object.is(csp, null)) {\n\t\t\treturn csp;\n\t\t} else {\n\t\t\treturn getMetaCSP();\n\t\t}\n\t} catch(err) {\n\t\tconsole.error(err);\n\t\treturn getMetaCSP();\n\t}\n});\n\nexport function getMetaCSP() {\n\tconst meta = document.head.querySelector('meta[http-equiv=\"Content-Security-Policy\"][content]');\n\n\tif (meta instanceof HTMLMetaElement) {\n\t\tconst directives = meta.content.trim().split(';').filter(str => str.length !== 0);\n\n\t\treturn Object.fromEntries(directives.map(directive => {\n\t\t\tconst [key, ...rest] = directive.trim().split(' ').filter(part => part.length !== 0);\n\t\t\treturn [key, rest];\n\t\t}));\n\t} else {\n\t\treturn {};\n\t}\n}\n\nexport async function GET(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\tpriority  ='auto',\n\treferrerPolicy = 'no-referrer',\n\theaders = new Headers(),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tif (typeof body !== 'undefined') {\n\t\turl = setURLParams(url, body);\n\t} else if (typeof url === 'string') {\n\t\turl = new URL(url, document.baseURI);\n\t}\n\n\tif (typeof signal === 'undefined' && Number.isInteger(timeout)) {\n\t\tsignal = AbortSignal.timeout(timeout);\n\t} else if (signal instanceof AbortController) {\n\t\tsignal = signal.signal;\n\t}\n\n\treturn await fetch(url, { method: 'GET', mode, credentials, referrerPolicy,\n\t\theaders, cache, redirect, priority, integrity, keepalive, signal, errorMessage });\n}\n\nexport async function POST(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tpriority = 'auto',\n\tredirect = 'follow',\n\treferrerPolicy = 'no-referrer',\n\theaders = new Headers(),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tif (typeof body === 'object' && ! (body instanceof FormData)) {\n\t\tif (body instanceof HTMLFormElement) {\n\t\t\tbody = new FormData(body);\n\t\t} else if (body instanceof File) {\n\t\t\tlet file;\n\t\t\t[body, file] = [new FormData(), body];\n\t\t\t// @TODO figure out a default param name for the file\n\t\t\t// @TODO handle multiple files and arrays containing files\n\t\t\tbody.set(file.name, file, file.name);\n\t\t} else {\n\t\t\tbody = JSON.stringify(body);\n\n\t\t\tif (headers instanceof Headers && ! headers.has('Content-Type')) {\n\t\t\t\theaders.set('Content-Type', TYPES.JSON);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (typeof signal === 'undefined' && Number.isInteger(timeout)) {\n\t\tsignal = AbortSignal.timeout(timeout);\n\t} else if (signal instanceof AbortController) {\n\t\tsignal = signal.signal;\n\t}\n\n\treturn await fetch(url, { method: 'POST', body, mode, credentials, referrerPolicy,\n\t\theaders, cache, redirect, priority, integrity, keepalive, signal, errorMessage });\n}\n\nexport async function DELETE(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\tpriority = 'auto',\n\treferrerPolicy = 'no-referrer',\n\theaders = new Headers(),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tif (typeof body !== 'undefined') {\n\t\turl = setURLParams(url, body);\n\t} else if (typeof url === 'string') {\n\t\turl = new URL(url, document.baseURI);\n\t}\n\n\tif (typeof signal === 'undefined' && Number.isInteger(timeout)) {\n\t\tsignal = AbortSignal.timeout(timeout);\n\t} else if (signal instanceof AbortController) {\n\t\tsignal = signal.signal;\n\t}\n\n\treturn await fetch(url, { method: 'DELETE', mode, credentials, referrerPolicy,\n\t\theaders, cache, redirect, priority, integrity, keepalive, signal, errorMessage });\n}\n\nexport async function getHTML(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\tpriority = 'auto',\n\treferrerPolicy = 'no-referrer',\n\theaders = new Headers({ Accept: TYPES.HTML }),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\thead = true,\n\tasFrag = true,\n\tsanitizer = undefined,\n\tpolicy,\n\terrorMessage,\n} = {}) {\n\tconst html = await getText(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\tif (isTrustPolicy(policy)) {\n\t\treturn parse(policy.createHTML(html), { asFrag, head });\n\t} else {\n\t\treturn parse(html, { head, asFrag, sanitizer, policy });\n\t}\n}\n\nexport const createTemplateGetter = (...args) => callOnce(() => getHTML(...args));\n\nexport async function getText(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\tpriority = 'auto',\n\treferrerPolicy = 'no-referrer',\n\theaders = new Headers({ Accept: TYPES.TEXT }),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tconst resp = await GET(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\treturn await resp.text();\n}\n\nexport async function getJSON(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\treferrerPolicy = 'no-referrer',\n\tpriority = 'auto',\n\theaders = new Headers({ Accept: TYPES.JSON }),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tconst resp = await GET(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\treturn await resp.json();\n}\n\nexport async function getFile(url, {\n\tname = null,\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\treferrerPolicy = 'no-referrer',\n\tpriority = 'auto',\n\theaders = new Headers(),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tif (typeof name !== 'string') {\n\t\tname = filename(url);\n\t}\n\n\tconst resp = await GET(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\tconst type = getType(resp);\n\treturn new File([await resp.blob()], name, { type });\n}\n\nexport async function submitForm(form) {\n\tif (typeof form === 'string') {\n\t\treturn await submitForm(document.forms[form]);\n\t} else if (form instanceof Event) {\n\t\tform.preventDefault();\n\t\treturn await submitForm(form.target);\n\t} else if (form instanceof HTMLFormElement) {\n\t\tswitch (form.method.toLowerCase()) {\n\t\t\tcase 'get':\n\t\t\t\treturn GET(form.action, { body: new FormData(form) });\n\n\t\t\tcase 'post':\n\t\t\t\treturn POST(form.action, { body: new FormData(form) });\n\n\t\t\tcase 'delete':\n\t\t\t\treturn DELETE(form.action, { body: new FormData(form) });\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported method: ${form.method}`);\n\t\t}\n\t}\n}\n\nexport const getManifest = callOnce(async function getManifest({ timeout, signal } = {}) {\n\tconst resp = await getLink('link[rel=\"manifest\"][href]', { timeout, signal });\n\treturn await resp.json();\n});\n\nexport async function getLink(link, { timeout, signal } = {}) {\n\tif (typeof link === 'string') {\n\t\treturn await getLink(document.querySelector(link, { timeout, signal }));\n\t} else if (! (link instanceof HTMLLinkElement)) {\n\t\tthrow new DOMException('Expected a <link>');\n\t} else if (link.href.length === 0) {\n\t\tthrow new DOMException('Missing `href` on <link>');\n\t} else {\n\t\tconst { href, integrity, type, referrerPolicy, crossOrigin } = link;\n\n\t\tlet credentials;\n\t\tconst mode = typeof crossOrigin === 'string' ? 'cors' : 'no-cors';\n\t\tconst headers = new Headers();\n\n\t\tif (mode === 'cors') {\n\t\t\tcredentials = crossOrigin === 'use-credentials' ? 'include' : 'omit';\n\t\t}\n\n\t\tif (typeof type === 'string') {\n\t\t\theaders.set('Accept', type);\n\t\t}\n\n\t\treturn await GET(href, { mode, credentials, headers, integrity, referrerPolicy, timeout, signal });\n\t}\n}\n\nexport async function postHTML(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\treferrerPolicy = 'no-referrer',\n\tpriority = 'auto',\n\theaders = new Headers({ Accept: TYPES.HTML }),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\thead = true,\n\tasFrag = true,\n\tsanitizer = undefined,\n\tpolicy,\n\terrorMessage,\n} = {}) {\n\tconst html = await postText(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\treturn parse(html, { head, asFrag, sanitizer, policy });\n}\n\nexport async function postJSON(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\treferrerPolicy = 'no-referrer',\n\tpriority = 'auto',\n\theaders = new Headers({ Accept: TYPES.JSON }),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tconst resp = await POST(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\treturn await resp.json();\n}\n\nexport async function postText(url, {\n\tbody = undefined,\n\tmode = 'cors',\n\tcache = 'default',\n\tcredentials = 'omit',\n\tredirect = 'follow',\n\treferrerPolicy = 'no-referrer',\n\tpriority = 'auto',\n\theaders = new Headers({ Accept: TYPES.TEXT }),\n\tintegrity = undefined,\n\tkeepalive = undefined,\n\tsignal = undefined,\n\ttimeout = null,\n\terrorMessage,\n} = {}) {\n\tconst resp = await POST(url, { body, mode, credentials, referrerPolicy, headers,\n\t\tcache, redirect, priority, integrity, keepalive, signal, timeout, errorMessage });\n\n\treturn await resp.text();\n}\n\nexport function navigateTo(to, {\n\tparams = {},\n\tutm: {\n\t\tsource: utm_source,\n\t\tmedium: utm_medium = 'referral',\n\t\tcontent: utm_content,\n\t\tcampaign: utm_campaign,\n\t\tterm: utm_term,\n\t} = {},\n\tallowedOrigins = [],\n\trequirePath = false,\n\torigin = location.origin,\n} = {}) {\n\tconst url = new URL(to, origin);\n\n\tif (! Array.isArray(allowedOrigins)) {\n\t\tthrow new TypeError('`allowedOrigins` must be an array');\n\t} else if (! (url.origin === location.origin || allowedOrigins.includes(url.origin))) {\n\t\tthrow new TypeError(`${url.origin} is not an allowed origin`);\n\t} else if (requirePath && url.pathname.length === 1) {\n\t\tthrow new TypeError('`pathname` is required');\n\t} else if (! isObject(params)) {\n\t\tthrow new TypeError('Expected `params` to be an object');\n\t} else {\n\t\tif (typeof utm_source === 'string') {\n\t\t\tObject.entries({...params, utm_source, utm_medium, utm_content, utm_campaign, utm_term })\n\t\t\t\t.filter(([,v]) => ! isNullish(v))\n\t\t\t\t.forEach(([k, v]) => url.searchParams.set(k, v));\n\t\t} else {\n\t\t\tObject.entries(params)\n\t\t\t\t.filter(([,v]) => ! isNullish(v))\n\t\t\t\t.forEach(([k, v]) => url.searchParams.set(k, v));\n\t\t}\n\n\t\tlocation.href = url.href;\n\t}\n}\n\nexport function postNav(url, data = {}, {\n\ttarget = '_self' ,\n\tenctype = TYPES.FORM_URL_ENCODED,\n\tsignal,\n} = {}) {\n\tif (! (signal instanceof AbortSignal && signal.aborted)) {\n\t\tconst form = document.createElement('form');\n\t\tconst inputs = Object.entries(data).map(([name, value]) => {\n\t\t\tconst input = document.createElement('input');\n\t\t\tinput.name = name;\n\t\t\tinput.type = 'hidden';\n\t\t\tinput.readOnly = true;\n\t\t\tinput.value = value;\n\t\t\treturn input;\n\t\t});\n\n\t\tform.action = url;\n\t\tform.method = 'POST';\n\t\tform.target = target;\n\t\tform.enctype = enctype;\n\t\tform.hidden = true;\n\t\tform.append(...inputs);\n\t\tform.addEventListener('submit', ({ target }) => setTimeout(() => target.remove(), 100), { signal });\n\n\t\trequestAnimationFrame(() => {\n\t\t\tdocument.body.append(form);\n\t\t\tform.submit();\n\t\t});\n\t}\n}\n\nexport { setURLParams, setUTMParams };\n","export const HTML = 'http://www.w3.org/1999/xhtml';\nexport const SVG = 'http://www.w3.org/2000/svg';\nexport const XLINK = 'http://www.w3.org/1999/xlink';\nexport const MATHML = 'http://www.w3.org/1998/Math/MathML';\n","/**\n * @copyright 2022-2023 Chris Zuber <admin@kernvalley.us>\n */\nimport { SVG, XLINK } from './namespaces.js';\nimport { isObject } from './utility.js';\nimport { css, data, attr } from './attrs.js';\nimport { SVG as TYPE } from './types.js';\n\nexport const rotate = n => `rotate(${n})`;\nexport const scale = n => `scale(${n})`;\nexport const translate = (x, y) => `translate(${x}, ${y})`;\n\nexport function createSVGFile(svg, { name = 'image.svg' } = {}) {\n\tif (svg instanceof SVGElement) {\n\t\treturn new File([svg.outerHTML], name, { type: TYPE });\n\t} else {\n\t\tthrow new TypeError('Expected an <svg>');\n\t}\n}\n\nexport function createSVGElement (tag, {\n\tfill, stroke, width, height, pathLength, children = [], id, classList = [],\n\tstyles, dataset,\n\tevents: {\n\t\tcapture,\n\t\tpassive,\n\t\tonce,\n\t\tsignal,\n\t\t...events\n\t} = {},\n\tanimation: {\n\t\tkeyframes,\n\t\tduration = 0,\n\t\tdelay = 0,\n\t\tendDelay = 0,\n\t\teasing = 'linear',\n\t\tdirection = 'normal',\n\t\tfill: svgFill = 'none',\n\t\titerations = 1,\n\t\titerationStart = 0,\n\t\tcomposite = 'replace',\n\t\titerationComposite = 'replace',\n\t\tpseudoElement,\n\t} = {},\n\t...rest } = {}) {\n\tconst el = document.createElementNS(SVG, tag);\n\t\n\tif (typeof id === 'string') {\n\t\tel.id = id;\n\t}\n\t\n\tif (Array.isArray(classList) && classList.length !== 0) {\n\t\tel.classList.add(...classList);\n\t}\n\n\tif (typeof fill === 'string') {\n\t\tel.setAttribute('fill', fill);\n\t}\n\n\tif (typeof stroke === 'string') {\n\t\tel.setAttribute('stroke', stroke);\n\t}\n\n\tif (typeof height === 'number' && ! Number.isNaN(height)) {\n\t\tel.setAttribute('height', height.toString());\n\t}\n\n\tif (typeof width === 'number' && ! Number.isNaN(width)) {\n\t\tel.setAttribute('width', width.toString());\n\t}\n\n\tif (typeof pathLength === 'number' && ! Number.isNaN(pathLength)) {\n\t\tel.setAttribute('pathLength', pathLength.toString());\n\t}\n\n\tif (typeof rest.title === 'string') {\n\t\tconst title = createSVGElement('title');\n\t\ttitle.textContent = rest.title;\n\t\tel.prepend(title);\n\t}\n\n\tif (Array.isArray(keyframes) || isObject(keyframes) && el.animate instanceof Function) {\n\t\tel.animate(keyframes, {\n\t\t\tduration, delay, endDelay, easing, direction, fill: svgFill, iterations,\n\t\t\titerationStart, composite, iterationComposite, pseudoElement,\n\t\t});\n\t}\n\t\n\tif (Array.isArray(children) && children.length !== 0) {\n\t\tel.append(...children.filter(node => (typeof node === 'string') || (node instanceof Element)));\n\t}\n\n\tif (isObject(styles)) {\n\t\tcss(el, styles);\n\t}\n\n\tif (isObject(events)) {\n\t\tObject.entries(events).forEach(\n\t\t\t([event, callback]) => el.addEventListener(event, callback, { capture, passive, once, signal })\n\t\t);\n\t}\n\n\tif (isObject(dataset)) {\n\t\tdata(el, dataset);\n\t}\n\n\tattr(el, rest);\n\n\treturn el;\n}\n\nexport function createSVG({\n\tid = null,\n\tfill = null,\n\tviewBox = null,\n\theight = null,\n\twidth = null,\n\tlabel = null,\n\tslot = null,\n\trole = 'img',\n\thidden = false,\n\tclassList = [],\n\tchildren = [],\n\tanimation,\n\tpart = [],\n\t...rest\n} = {}) {\n\tconst svg = createSVGElement('svg', { width, height, fill, animation, children, id, classList, ...rest });\n\n\tsvg.setAttribute('role', role);\n\n\tif (typeof viewBox === 'string') {\n\t\tsvg.setAttributeNS(null, 'viewBox', viewBox);\n\t} else if (Array.isArray(viewBox)) {\n\t\tsvg.setAttributeNS(null, 'viewBox', viewBox.map(n => n.toString()).join(' '));\n\t}\n\n\tif (typeof label === 'string') {\n\t\tsvg.setAttribute('aria-label', label);\n\t}\n\n\tif (hidden === true) {\n\t\tsvg.setAttribute('aria-hidden', 'true');\n\t}\n\n\tif (typeof slot === 'string') {\n\t\tsvg.slot = slot;\n\t}\n\n\tif (Array.isArray(classList) && classList.length !== 0) {\n\t\tsvg.classList.add(...classList);\n\t}\n\n\tif (Array.isArray(part) && part.length !== 0) {\n\t\tif('part' in svg) {\n\t\t\tsvg.part.add(...part);\n\t\t} else {\n\t\t\tsvg.setAttribute('part', part.join(' '));\n\t\t}\n\t}\n\n\treturn svg;\n}\n\nexport function useSVG(sprite, {\n\tid = null,\n\tsrc = '/img/icons.svg',\n\tfill = null,\n\theight = null,\n\twidth = null,\n\tslot = null,\n\tpart = [],\n\tclassList = [],\n\tlabel = null,\n\tanimation,\n\t...rest\n} = {}) {\n\tconst svg = createSVG({ id, fill, height, width, classList, label, slot, part, animation, hidden: true, ...rest });\n\tconst use = createSVGElement('use');\n\n\tif (typeof src === 'string') {\n\t\tconst url = new URL(src, document.baseURI);\n\t\turl.hash = `#${sprite}`;\n\t\tuse.setAttributeNS(XLINK, 'xlink:href', url.href);\n\t} else {\n\t\tuse.setAttributeNS(XLINK, 'xlink:href', `#${sprite}`);\n\t}\n\n\tsvg.append(use);\n\n\treturn svg;\n}\n\nexport function createPath(d, { id, fill, stroke, pathLength, animation, ...rest } = {}) {\n\tconst path = createSVGElement('path', { id, fill, stroke, pathLength, animation, ...rest });\n\n\tif (Array.isArray(d) && d.length !== 0) {\n\t\tpath.setAttribute('d', d.join(' '));\n\t} else if (typeof d === 'string') {\n\t\tpath.setAttribute('d', d);\n\t} else {\n\t\tthrow new TypeError('Invalid `d` attribute in <path>.');\n\t}\n\n\treturn path;\n}\n\nexport function createGroup({ id, fill, stroke, children, animation, ...attrs }) {\n\treturn createSVGElement('g', { id, fill, stroke, children, animation, ...attrs });\n}\n\nexport function createRect({ id, width, height, x, y, rx, ry, fill, stroke, pathLength, animation, ...rest }) {\n\treturn createSVGElement('rect', { id, width, height, x, y, rx, ry, fill, stroke, pathLength, animation, ...rest });\n}\n\nexport function createCircle({ id, width, height, cx, cy, r, fill, stroke, pathLength, animation, ...rest }) {\n\treturn createSVGElement('circle', { id, width, height, cx, cy, r, fill, stroke, pathLength, animation, ...rest });\n}\n\nexport function createEllipse({ id, width, height, cx, cy, rx, ry, fill, stroke, pathLength, animation, ...rest }) {\n\treturn createSVGElement('ellipse', { id, width, height, cx, cy, rx, ry, fill, stroke, pathLength, animation, ...rest });\n}\n\nexport function createPolygon(points, { id, fill, stroke, pathLength, animation, ...rest } = {}) {\n\tconst polygon = createSVGElement('polygon', { id, fill, stroke, pathLength, animation, ...rest });\n\n\tif (Array.isArray(points) && points.length !== 0) {\n\t\tpolygon.setAttribute('points', points.map(([x, y]) => `${x},${y}`).join(' '));\n\t} else if (typeof points === 'string') {\n\t\tpolygon.setAttribute('points', points);\n\t} else {\n\t\tthrow new TypeError('Invalid `points` attribute in <polygon>.');\n\t}\n\n\treturn polygon;\n}\n\nexport function createPolyline(points, { id, fill, stroke, pathLength, animation, ...rest } = {}) {\n\tconst polyline = createSVGElement('polyline', { id, fill, stroke, pathLength, animation, ...rest });\n\n\tif (Array.isArray(points) && points.length !== 0) {\n\t\tpolyline.setAttribute('points', points.map(([x, y]) => `${x},${y}`).join(' '));\n\t} else if (typeof points === 'string') {\n\t\tpolyline.setAttribute('points', points);\n\t} else {\n\t\tthrow new TypeError('Invalid `points` attribute in <polygon>.');\n\t}\n\n\treturn polyline;\n}\n\nexport function createLine([[x1, y1], [x2, y2]], { id, fill, stroke, pathLength, animation, ...rest } = {}) {\n\tif (! [x1, x2, y1, y2].every(n => typeof n === 'number' && ! Number.isNaN(n))) {\n\t\tthrow new TypeError('Invalid coordinates in <line>.');\n\t} else {\n\t\treturn createSVGElement('line', { id, fill, stroke, x1, y1, x2, y2, pathLength, animation, ...rest });\n\t}\n}\n\nexport { TYPE };\n","import { getJSON } from '../../js/std-js/http.js';\nimport { createSVG } from '../../js/std-js/svg.js';\nexport const ENDPOINT = 'https://api.openweathermap.org';\nexport const ICON_SRC = 'https://openweathermap.org/img/wn/';\nexport const VERSION = 2.5;\nimport { days } from '../../js/std-js/date-consts.js';\nconst TZ = '.' + new Date().toISOString().split('.').pop();\nconst dateString = date => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;\n\nexport const shadows = new Map();\n\nexport function getSprite(icon) {\n\t// @SEE https://openweathermap.org/weather-conditions\n\tswitch(icon) {\n\t\tcase '01d': return 'weather-clear';\n\t\tcase '01n': return 'weather-clear-night';\n\t\tcase '02d':\n\t\tcase '03d':\n\t\tcase '04d': return 'weather-few-clouds';\n\t\tcase '02n':\n\t\tcase '03n':\n\t\tcase '04n': return 'weather-few-clouds-night';\n\t\tcase '09d':\n\t\tcase '09n': return 'weather-showers-scattered';\n\t\tcase '10d':\n\t\tcase '10n': return 'weather-showers';\n\t\tcase '11d':\n\t\tcase '11n': return 'weather-storm';\n\t\tcase '13d':\n\t\tcase '13n': return 'weather-snow';\n\t\tcase '50d':\n\t\tcase '50n': return 'weather-fog';\n\t\tdefault: return 'weather-storm';\n\t}\n}\n\nexport function getIconSrc(icon) {\n\treturn new URL(`${icon}@2x.png`, ICON_SRC).href;\n}\n\nexport function createIcon(symbol, owner = document) {\n\tconst sprite = owner.getElementById(symbol);\n\treturn createSVG({\n\t\tfill: 'currentColor',\n\t\tviewBox: sprite.getAttribute('viewBox'),\n\t\trole: 'presentation',\n\t\tchildren: [...sprite.children].map(node => node.cloneNode(true)),\n\t});\n}\n\nexport function getIcon(icon) {\n\tconst img = new Image();\n\timg.decoding = 'async';\n\timg.src = getIconSrc(icon);\n\timg.slot = 'icon';\n\treturn img;\n}\n\nexport async function getForecastByPostalCode(appid, postalCode, {\n\tunits = 'imperial',\n\tcountry = 'us',\n\tlang = 'en',\n\tsignal,\n} = {}) {\n\tconst { city = null, list = [] } = await getJSON(new URL(`/data/${VERSION}/forecast`, ENDPOINT), {\n\t\tbody: { appid, zip: `${postalCode},${country}`, units, lang },\n\t\tsignal,\n\t}) || {};\n\n\tconst forecast = list.reduce((forecast, entry) => {\n\t\tconst date = new Date(entry.dt_txt.replace(' ', 'T') + TZ);\n\t\tconst day = dateString(date);\n\n\t\tif (! forecast.hasOwnProperty(day)) {\n\t\t\tforecast[day] = {\n\t\t\t\tday,\n\t\t\t\tdow: days[date.getDay()].name,\n\t\t\t\tdate,\n\t\t\t\thigh: Number.MIN_SAFE_INTEGER,\n\t\t\t\tlow: Number.MAX_SAFE_INTEGER,\n\t\t\t\ttimes: [],\n\t\t\t\tconditions: null,\n\t\t\t\ticon: '01d',\n\t\t\t};\n\t\t}\n\n\t\tforecast[day].times.push({\n\t\t\ttime: date.toLocaleTimeString(),\n\t\t\tconditions: entry.main,\n\t\t\tweather: entry.weather[0],\n\t\t\tcloud: entry.clouds,\n\t\t\twind: entry.wind,\n\t\t});\n\n\t\tforecast[day].high = Math.max(forecast[day].high, entry.main.temp);\n\t\tforecast[day].low = Math.min(forecast[day].low, entry.main.temp);\n\n\t\tif (entry.weather[0].icon > forecast[day].icon) {\n\t\t\tforecast[day].icon = entry.weather[0].icon;\n\t\t\tforecast[day].conditions = entry.weather[0].description;\n\t\t}\n\n\t\treturn forecast;\n\t}, {});\n\n\treturn { city, forecast };\n}\n\nexport async function getWeatherByPostalCode(appid, postalCode, {\n\tunits = 'imperial',\n\tcountry = 'us',\n\tlang = 'en',\n\tsignal,\n} = {}) {\n\treturn await getJSON(new URL(`/data/${VERSION}/weather`, ENDPOINT), {\n\t\tbody: { appid, zip: `${postalCode},${country}`, units, lang },\n\t\tsignal,\n\t});\n}\n\nexport async function getSlot(el, name) {\n\tawait el.ready;\n\tif (shadows.has(el)) {\n\t\treturn shadows.get(el).querySelector(`slot[name=\"${name}\"]`);\n\t} else {\n\t\treturn null;\n\t}\n}\n\nexport async function getAssigned(el, name) {\n\tconst slot = await getSlot(el, name);\n\tif (slot instanceof HTMLElement) {\n\t\treturn slot.assignedNodes();\n\t} else {\n\t\treturn [];\n\t}\n}\n\nexport async function clearSlot(el, name) {\n\tconst assigned = await getAssigned(el, name);\n\tassigned.forEach(el => el.remove());\n}\n\nexport async function clearSlots(el, ...names) {\n\tawait el.ready;\n\tif (shadows.has(el)) {\n\t\tconst shadow = shadows.get(el);\n\t\tnames.forEach(name => {\n\t\t\tconst slot = shadow.querySelector(`slot[name=\"${name}\"]`);\n\t\t\tif (slot instanceof HTMLElement) {\n\t\t\t\tslot.assignedNodes().forEach(el => el.remove());\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}\n","const url = import.meta.url.endsWith('.min.js')\n\t? new URL('https://cdn.kernvalley.us').href\n\t: new URL(import.meta.url).href;\n\nexport const meta = { url };\n","export const supported = window.customElements instanceof Object;\n\nexport function isDefined(...tags) {\n\treturn supported && tags.every(tag => typeof customElements.get(tag) !== 'undefined');\n}\n\nexport function registerCustomElement(tag, cls, ...rest) {\n\tif (! supported) {\n\t\tconsole.error(new Error('`customElements` not supported'));\n\t\treturn false;\n\t} else if (isDefined(tag)) {\n\t\tconsole.warn(new Error(`<${tag}> is already defined`));\n\t\t// Returns true/false if element being registered matches given class\n\t\treturn customElements.get(tag) === cls;\n\t} else {\n\t\tcustomElements.define(tag, cls, ...rest);\n\t\treturn true;\n\t}\n}\n\nexport async function getCustomElement(tag) {\n\tif (supported) {\n\t\tawait customElements.whenDefined(tag);\n\t\treturn customElements.get(tag);\n\t} else {\n\t\tthrow new Error('`customElements` not supported');\n\t}\n}\n\nexport async function createCustomElement(tag, ...args) {\n\tconst Pro = await getCustomElement(tag);\n\treturn new Pro(...args);\n}\n\nexport async function whenDefined(...els) {\n\tif (supported) {\n\t\tawait Promise.all(els.map(el => customElements.whenDefined(el)));\n\t} else {\n\t\tthrow new Error('`customElements` not supported');\n\t}\n}\n\nexport async function defined(...els) {\n\tconsole.error('`defined()` is deprecated. Please use `whenDefined()` instead');\n\tawait whenDefined(...els);\n}\n","import { getDeferred } from './promises.js';\n\nconst protectedData = new WeakMap();\n\nconst observer = new IntersectionObserver((entries, observer) => {\n\tentries.forEach(entry => {\n\t\tif (entry.isIntersecting) {\n\t\t\tconst { resolve } = protectedData.get(entry.target);\n\t\t\tprotectedData.delete(entry.target);\n\t\t\tresolve(entry);\n\t\t\tobserver.unobserve(entry.target);\n\t\t}\n\t});\n}, {\n\trootMargin: `${Math.min(250, Math.floor(screen.height * 0.3))}px`,\n});\n\nexport async function whenIntersecting(target, { signal, base = document } = {}) {\n\tconst { resolve, reject, promise } = getDeferred();\n\n\tif (signal instanceof AbortSignal && signal.aborted) {\n\t\treject(signal.reason);\n\t} else if (typeof target === 'string') {\n\t\twhenIntersecting(base.querySelector(target), { signal }).then(resolve).catch(reject);\n\t} else if (! (target instanceof Element)) {\n\t\treject(new TypeError('Non-elements can never intersect'));\n\t} else if (protectedData.has(target)) {\n\t\tprotectedData.get(target).promise.then(resolve).catch(reject);\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignal.addEventListener('abort', ({ target: { reason }}) => {\n\t\t\t\treject(reason);\n\t\t\t}, { once: true });\n\t\t}\n\t} else {\n\t\tprotectedData.set(target, { resolve, reject, promise });\n\t\tobserver.observe(target);\n\n\t\tif (signal instanceof AbortSignal) {\n\t\t\tsignal.addEventListener('abort', ({ target: { reason }}) => {\n\t\t\t\tobserver.unobserve(target);\n\n\t\t\t\tif (protectedData.has(target)) {\n\t\t\t\t\tprotectedData.get(target).reject(reason);\n\t\t\t\t\tprotectedData.delete(target);\n\t\t\t\t}\n\t\t\t}, { once: true });\n\t\t}\n\t}\n\n\treturn promise;\n}\n","import { meta } from '../import.meta.js';\nimport { registerCustomElement } from '../js/std-js/custom-elements.js';\nimport { when } from '../js/std-js/dom.js';\nimport { getHTML } from '../js/std-js/http.js';\nimport { getDeferred } from '../js/std-js/promises.js';\nimport { whenIntersecting } from '../js/std-js/intersect.js';\n\nlet metaUrl = meta.url;\nlet base    = null;\n\nconst observed = new WeakMap();\n\nconst observer = ('IntersectionObserver' in window)\n\t? new IntersectionObserver((entries, observer) => {\n\t\tentries.forEach(({ target, isIntersecting }) => {\n\t\t\tif (isIntersecting && observed.has(target)) {\n\t\t\t\tconst opts = observed.get(target);\n\t\t\t\topts.resolved = true;\n\t\t\t\topts.resolve(target);\n\t\t\t\tobserver.unobserve(target);\n\t\t\t\tobserved.delete(target);\n\t\t\t}\n\t\t});\n\t}, {\n\t\trootMargin: `${Math.floor(0.5 * Math.max(screen.height, 200))}px`,\n\t})\n\t: {observe: () => {}, has: () => false, unobserve: () => {}};\n\nexport default class HTMLCustomElement extends HTMLElement {\n\t/**\n\t * @deprecated Use `whenIntersecting` instead\n\t */\n\tlazyLoad(lazy = true) {\n\t\tif (lazy && ! observed.has(this)) {\n\t\t\tconst opts = { resolve: null, resolved: false, promise: Promise.resolve() };\n\t\t\topts.promise = new Promise(resolve => opts.resolve = resolve);\n\t\t\tobserved.set(this, opts);\n\t\t\tobserver.observe(this);\n\t\t} else if (lazy === false) {\n\t\t\tif (observed.has(this)) {\n\t\t\t\tconst { resolve } = observed.get(this);\n\t\t\t\tresolve(this);\n\t\t\t}\n\t\t\tobserved.delete(this);\n\t\t\tobserver.unobserve(this);\n\t\t}\n\t}\n\n\tconnectedCallback() {\n\t\tthis.dispatchEvent(new Event('connected'));\n\t}\n\n\tget loading() {\n\t\treturn this.getAttribute('loading') || 'auto';\n\t}\n\n\tset loading(val) {\n\t\tif (typeof val === 'string' && val.length !== 0) {\n\t\t\tthis.setAttribute('loading', val);\n\t\t} else {\n\t\t\tthis.setAttribute('loading', val);\n\t\t}\n\t}\n\n\tget ready() {\n\t\tconst { promise, resolve } = getDeferred();\n\n\t\tif (this.shadowRoot !== null && this.shadowRoot.childElementCount === 0) {\n\t\t\twhen(this, 'ready').then(() => resolve(this));\n\t\t} else {\n\t\t\tresolve(this);\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tget stylesLoaded() {\n\t\treturn this.ready.then(() => {\n\t\t\tif (this.shadowRoot !== null) {\n\t\t\t\tconst stylesheets = this.shadowRoot.querySelectorAll('link[rel=\"stylesheet\"][href]:not(:disabled)');\n\t\t\t\treturn Promise.allSettled([...stylesheets].map(async link => {\n\t\t\t\t\tif (link.sheet === null) {\n\t\t\t\t\t\treturn Promise.race([\n\t\t\t\t\t\t\twhen(link, 'load'),\n\t\t\t\t\t\t\twhen(link, 'error'),\n\t\t\t\t\t\t]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn Promise.resolve();\n\t\t\t\t\t}\n\t\t\t\t\t// @TODO Wait for `@import` loading\n\t\t\t\t\t// link.sheet.rules.filter(rule => rule.type === CSSRule.IMPORT_RULE)\n\t\t\t\t}));\n\t\t\t}\n\t\t\treturn this;\n\t\t});\n\t}\n\n\tget whenConnected() {\n\t\tconst { resolve, promise } = getDeferred();\n\n\t\tif (this.isConnected) {\n\t\t\tresolve();\n\t\t} else {\n\t\t\twhen(this, 'connected').then(() => resolve());\n\t\t}\n\n\t\treturn promise;\n\t}\n\n\tget whenLoad() {\n\t\tif (! ('IntersectionObserver' in globalThis)) {\n\t\t\treturn Promise.resolve(this);\n\t\t} else if (this.loading === 'lazy') {\n\t\t\treturn whenIntersecting(this).then(() => this);\n\t\t} else {\n\t\t\treturn Promise.resolve(this);\n\t\t}\n\t}\n\n\tasync getSlot(slot) {\n\t\tawait this.ready;\n\t\treturn this.shadowRoot.querySelector(`slot[name=\"${CSS.escape(slot)}\"]`);\n\t}\n\n\tasync getSlotted(slot) {\n\t\tconst el = await this.getSlot(slot);\n\n\t\tif (el instanceof HTMLElement) {\n\t\t\treturn el.assignedElements();\n\t\t} else {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\tasync getSlottedItem(slot, item = 0) {\n\t\tconst slotted = await this.getSlotted(slot);\n\t\treturn slotted.length > item ? slotted[item] : null;\n\t}\n\n\tasync clearSlot(slot) {\n\t\tconst slotted = await this.getSlotted(slot);\n\t\tslotted.forEach(el => el.remove());\n\t}\n\n\tasync setSlot(slot, content, {\n\t\treplace   = true,\n\t\ttag       = 'span',\n\t\tattrs     = {},\n\t\tdata      = {},\n\t\tcss       = {},\n\t\tclassList = [],\n\t\tparts     = [],\n\t} = {}) {\n\t\tlet el = null;\n\t\tconst current = await this.getSlotted(slot);\n\n\t\tif (replace && current.length === 1 && typeof content === 'string' && current[0].tagName === tag.toUpperCase()) {\n\t\t\tel = current[0];\n\t\t\tel.textContent = content;\n\t\t} else if (content instanceof HTMLElement) {\n\t\t\tel = content;\n\t\t} else if (typeof content === 'string') {\n\t\t\tel = document.createElement(tag);\n\t\t\tel.textContent = content;\n\t\t} else {\n\t\t\tel = document.createElement(tag);\n\t\t}\n\n\t\tObject.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));\n\t\tObject.entries(data).forEach(([k, v]) => el.dataset[k] = v);\n\t\tObject.entries(css).forEach(([k, v]) => el.style.setProperty(k, v));\n\n\t\tif (classList.length !== 0) {\n\t\t\tel.classList.add(...classList);\n\t\t}\n\n\t\tif ('part' in el && Array.isArray(parts) && parts.length !== 0) {\n\t\t\tel.part.add(...parts);\n\t\t}\n\n\t\tel.slot = slot;\n\n\t\tif (replace) {\n\t\t\tif (current.length === 0) {\n\t\t\t\tthis.append(el);\n\t\t\t} else if (current.length !== 1) {\n\t\t\t\tcurrent.forEach(s => s.remove());\n\t\t\t\tthis.append(el);\n\t\t\t} else if (! current[0].isSameNode(el)) {\n\t\t\t\tcurrent[0].replaceWith(el);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.append(el);\n\t\t}\n\t\treturn el;\n\t}\n\n\tasync getTemplate(url, init = {}) {\n\t\turl = new URL(url, HTMLCustomElement.base);\n\t\tconst frag = await getHTML(url, init);\n\n\t\tfrag.querySelectorAll('link[href]').forEach(link => link.href = new URL(link.getAttribute('href'), url).href);\n\t\tfrag.querySelectorAll('img[src]').forEach(img => img.src = new URL(img.getAttribute('src'), url).href);\n\t\tfrag.querySelectorAll('script[src]').forEach(script => script.src = new URL(script.getAttribute('src'), url).href);\n\t\treturn frag;\n\t}\n\n\tstatic get base() {\n\t\tif (typeof base === 'string') {\n\t\t\treturn base;\n\t\t} else if (document.documentElement.dataset.hasOwnProperty('componentBase')) {\n\t\t\treturn new URL(document.documentElement.dataset.componentBase, document.baseURI).href;\n\t\t} else {\n\t\t\treturn metaUrl;\n\t\t}\n\t}\n\n\tstatic set base(val) {\n\t\tbase = val;\n\t}\n\n\tstatic register(tag, cls, ...rest) {\n\t\treturn registerCustomElement(tag, cls, ...rest);\n\t}\n}\n","import { shadows, clearSlot, getWeatherByPostalCode, createIcon, getIcon, getSprite } from './helper.js';\nimport { createPolicy } from '../../js/std-js/trust.js';\nimport { getURLResolver } from '../../js/std-js/utility.js';\nimport { meta } from '../../import.meta.js';\nimport { getHTML } from '../../js/std-js/http.js';\nimport HTMLCustomElement from '../custom-element.js';\n\nconst resolveURL = getURLResolver({ base: meta.url, path: '/components/weather/' });\nconst policy = createPolicy('weather-current#html', {\n\tcreateHTML: input => input,\n});\nconst getTemplate = async () => getHTML(resolveURL('./current.html'), { policy })\n\t.then(tmp => {\n\t\ttmp.querySelectorAll('link[href]').forEach(link => link.href = resolveURL(link.getAttribute('href')));\n\t\treturn tmp;\n\t});\n\n\nHTMLCustomElement.register('weather-current', class HTMLWeatherForecastElement extends HTMLCustomElement {\n\tconstructor({ appId = null, postalCode = null, loading = null } = {}) {\n\t\tsuper();\n\n\t\tthis.addEventListener('connected', async () => {\n\t\t\tconst shadow = this.attachShadow({ mode: 'closed' });\n\t\t\tconst internals = this.attachInternals();\n\t\t\tinternals.role = 'group';\n\t\t\tinternals.ariaBusy = 'true';\n\t\t\tinternals.ariaLabel = 'Local Weather';\n\t\t\tif (typeof appId === 'string') {\n\t\t\t\tthis.appId = appId;\n\t\t\t}\n\n\t\t\tif (typeof postalCode === 'string' || typeof postalCode === 'number') {\n\t\t\t\tthis.postalCode = postalCode;\n\t\t\t}\n\n\t\t\tif (typeof loading === 'string') {\n\t\t\t\tthis.loading = loading;\n\t\t\t}\n\n\t\t\tawait Promise.all([this.whenConnected, this.whenLoad]);\n\n\t\t\tconst tmp = await getTemplate();\n\t\t\tshadow.append(tmp);\n\t\t\tshadows.set(this, shadow);\n\t\t\tthis.dispatchEvent(new Event('ready'));\n\t\t\tinternals.ariaBusy = 'false';\n\t\t}, { once: true });\n\t}\n\n\tasync connectedCallback() {\n\t\tthis.dispatchEvent(new Event('connected'));\n\t\tthis.update(this);\n\t}\n\n\tasync update() {\n\t\tthis.ready.then(async () => {\n\t\t\tconst {name, main, wind, dt, weather} = await getWeatherByPostalCode(this.appId, this.postalCode);\n\t\t\tthis.city = name;\n\t\t\tthis.temp = main.temp;\n\t\t\tthis.conditions = weather[0].description;\n\t\t\tthis.windSpeed = wind.speed;\n\t\t\tthis.icon = createIcon(getSprite(weather[0].icon), shadows.get(this));\n\t\t\tthis.updated = dt;\n\t\t});\n\t}\n\n\tget appId() {\n\t\treturn this.getAttribute('appid');\n\t}\n\n\tset appId(val) {\n\t\tif (typeof val === 'string') {\n\t\t\tthis.setAttribute('appid', val);\n\t\t} else {\n\t\t\tthis.removeAttribute('appid');\n\t\t}\n\t}\n\n\tset city(val) {\n\t\tthis._set('city', val);\n\t}\n\n\tset icon(val) {\n\t\tif (typeof val === 'string') {\n\t\t\tconst icon = getIcon(val);\n\t\t\tconsole.info(val);\n\t\t\tclearSlot(this, 'icon').then(() => this.append(icon));\n\t\t} else if (val instanceof Element) {\n\t\t\tval.slot = 'icon';\n\t\t\tclearSlot(this, 'icon').then(() => this.append(val));\n\t\t}\n\t}\n\n\tset sprite(symbol) {\n\t\tthis.icon = createIcon(symbol, shadows.get(this));\n\t}\n\n\tset temp(val) {\n\t\tthis._set('temp', Math.round(val));\n\t}\n\n\tset updated(val) {\n\t\tif (typeof val === 'number' || typeof val === 'string') {\n\t\t\t// Convert to ms if int\n\t\t\tconst date = new Date(Number.isInteger(val) ? val * 1000 : val);\n\t\t\tconst el = document.createElement('time');\n\t\t\tel.textContent = date.toLocaleTimeString();\n\t\t\tel.dateTime = date.toISOString();\n\t\t\tel.slot = 'updated';\n\t\t\tclearSlot(this, 'updated').then(() => this.append(el));\n\t\t} else if (val instanceof HTMLElement) {\n\t\t\tval.slot = 'updated';\n\t\t\tclearSlot(this, 'updated').then(() => this.append(val));\n\t\t}\n\t}\n\n\tget loading() {\n\t\treturn this.getAttribute('loading') || 'auto';\n\t}\n\n\tset loading(val) {\n\t\tif (typeof val === 'string' && val.length !== 0) {\n\t\t\tthis.setAttribute('loading', val);\n\t\t} else {\n\t\t\tthis.removeAttribute('loading');\n\t\t}\n\t}\n\n\tget whenConnected() {\n\t\tif (this.isConnected) {\n\t\t\treturn Promise.resolve();\n\t\t} else {\n\t\t\treturn new Promise(resolve => this.addEventListener('connected', () => resolve(), { once: true }));\n\t\t}\n\t}\n\n\tset windSpeed(val) {\n\t\tthis._set('windSpeed', val);\n\t}\n\n\tset conditions(val) {\n\t\tthis._set('conditions', val);\n\t}\n\n\tget postalCode() {\n\t\treturn this.getAttribute('postalcode');\n\t}\n\n\tset postalCode(val) {\n\t\tthis.setAttribute('postalcode', val);\n\t}\n\n\tget ready() {\n\t\treturn new Promise(resolve => {\n\t\t\tif (shadows.has(this)) {\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tthis.addEventListener('ready', () => resolve(), {once: true});\n\t\t\t}\n\t\t});\n\t}\n\n\tget theme() {\n\t\treturn this.getAttribute('theme') || 'auto';\n\t}\n\n\tset theme(val) {\n\t\tswitch(val.toLowerCase()) {\n\t\t\tcase 'light':\n\t\t\t\tthis.setAttribute('theme', 'light');\n\t\t\t\tbreak;\n\n\t\t\tcase 'dark':\n\t\t\t\tthis.setAttribute('theme', 'dark');\n\t\t\t\tbreak;\n\n\t\t\tcase '':\n\t\t\tcase 'auto':\n\t\t\t\tthis.removeAttribute('theme');\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error(`Unsupported theme: ${val}`);\n\t\t}\n\t}\n\n\tasync _set(name, value, {tag = 'span', attrs = {}} = {}) {\n\t\tconst el = document.createElement(tag);\n\t\tel.slot = name;\n\t\tel.textContent = value;\n\t\tObject.entries(attrs).forEach(({key, val}) => el.setAttribute(key, val));\n\t\tawait clearSlot(this, name);\n\t\tthis.append(el);\n\t}\n\n\tasync attributeChangedCallback(name, oldValue, newValue) {\n\t\tswitch(name) {\n\t\t\tcase 'appid':\n\t\t\t\tthis.dispatchEvent(new CustomEvent('appidchange', {detail: {oldValue, newValue}}));\n\t\t\t\tbreak;\n\n\t\t\tcase 'postalcode':\n\t\t\t\tthis.dispatchEvent(new CustomEvent('locationchange', {detail: {oldValue, newValue}}));\n\t\t\t\tbreak;\n\n\t\t\tcase 'theme':\n\t\t\t\tthis.dispatchEvent(new CustomEvent('themechange', {detail: {oldValue, newValue}}));\n\t\t\t\tbreak;\n\n\t\t\tcase 'units':\n\t\t\t\tthis.dispatchEvent(new CustomEvent('unitschange', {detail: {oldValue, newValue}}));\n\t\t\t\tbreak;\n\n\t\t\tcase 'loading':\n\t\t\t\tthis.lazyLoad(newValue === 'lazy');\n\t\t\t\tbreak;\n\n\t\t\tdefault: throw new Error(`Unhandled attribute changed: ${name}`);\n\t\t}\n\t}\n\n\tstatic get observedAttributes() {\n\t\treturn [\n\t\t\t'appid',\n\t\t\t'loading',\n\t\t\t'postalcode',\n\t\t\t'units',\n\t\t\t'theme',\n\t\t];\n\t}\n});\n"],"names":["setAttr","el","attr","val","elementNs","policy","tagName","attribute","supported","trustedTypes","getAttributeType","toLowerCase","setAttributeNs","createScriptURL","setAttribute","setAttributeNS","createScript","createHTML","globalThis","EventTarget","createPolicy","Function","isTrustPolicy","TrustedTypePolicy","isHTML","input","isScriptURL","URL","getDefaultPolicy","isScript","defaultPolicy","funcs","WeakMap","async","registerServiceWorker","source","scope","type","updateViaCache","resolve","reject","promise","getDeferred","navigator","serviceWorker","register","then","catch","TypeError","DOMException","isObject","thing","Object","is","Array","isArray","callOnce","callback","thisArg","once","args","has","get","what","constructor","name","retVal","apply","this","err","delete","set","setURLParams","forURL","params","url","document","baseURI","HTMLFormElement","FormData","URLSearchParams","fromEntries","entries","forEach","k","v","Number","isNaN","searchParams","length","Date","getTime","isNullish","toString","documentElement","dataset","ready","addEventListener","target","update","customElements","whenDefined","body","requireInteraction","actions","title","action","close","location","reload","reloadOnUpdate","console","error","features","createElement","eventFeatures","nativeSignal","AbortController","prototype","hasOwnProperty","signal","passive","capture","options","removeEventListener","seal","getEventFeatures","addListener","targets","events","query","of","event","listen","aborted","signalAborted","finally","deferred","Promise","throwIfAborted","reason","Map","locks","request","checkSupport","window","TEXT","HTML","JSON","props","namespace","Element","p","removeAttribute","removeAttributeNS","toggleAttribute","toISOString","href","stringify","readyStates","readyStateIndex","state","readyState","indexOf","base","matches","from","querySelectorAll","push","Symbol","iterator","when","controller","AbortSignal","abort","items","ev","cb","on","whenReadyState","stateIndex","settled","parse","text","asFrag","sanitizer","undefined","parser","DOMParser","tmp","innerHTML","sanitize","content","parseAsFragment","parseFromString","symbols","resp","HTTPException","Error","Response","message","cause","super","status","statusText","defineProperty","value","configurable","writable","enumerable","json","bodyUsed","headers","ok","redirected","toJSON","handleResponse","handleError","fetch","opts","Request","race","errorMessage","getHTTPCSP","method","directives","trim","split","filter","str","map","directive","key","rest","part","getMetaCSP","meta","head","querySelector","HTMLMetaElement","GET","mode","cache","credentials","redirect","priority","referrerPolicy","Headers","integrity","keepalive","timeout","isInteger","getHTML","Accept","TYPES.HTML","html","TYPES.TEXT","getText","getLink","link","HTMLLinkElement","crossOrigin","csp","SVG","createSVGElement","tag","fill","stroke","width","height","pathLength","children","id","classList","styles","animation","keyframes","duration","delay","endDelay","easing","direction","svgFill","iterations","iterationStart","composite","iterationComposite","pseudoElement","createElementNS","add","textContent","prepend","animate","append","node","style","setProperty","removeProperty","css","data","ICON_SRC","pop","shadows","createIcon","symbol","owner","sprite","getElementById","viewBox","label","slot","role","hidden","svg","n","join","createSVG","getAttribute","cloneNode","getIcon","icon","img","Image","decoding","src","getIconSrc","getWeatherByPostalCode","appid","postalCode","units","country","lang","TYPES.JSON","getJSON","zip","getAssigned","getSlot","HTMLElement","assignedNodes","clearSlot","remove","currentScript","endsWith","registerCustomElement","cls","tags","every","isDefined","warn","define","protectedData","observer","IntersectionObserver","entry","isIntersecting","unobserve","rootMargin","Math","min","floor","screen","whenIntersecting","observe","metaUrl","observed","resolved","max","HTMLCustomElement","lazyLoad","lazy","connectedCallback","dispatchEvent","Event","loading","shadowRoot","childElementCount","stylesLoaded","stylesheets","allSettled","sheet","whenConnected","isConnected","whenLoad","CSS","escape","assignedElements","item","slotted","getSlotted","replace","attrs","parts","current","toUpperCase","s","isSameNode","replaceWith","init","frag","script","componentBase","static","resolveURL","path","getURLResolver","freeze","appId","shadow","attachShadow","internals","attachInternals","ariaBusy","ariaLabel","all","getTemplate","main","wind","dt","weather","city","temp","conditions","description","windSpeed","speed","getSprite","updated","_set","info","round","date","toLocaleTimeString","dateTime","theme","oldValue","newValue","CustomEvent","detail","observedAttributes"],"mappings":"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"}